{"version":3,"file":"index.production.js","sources":["../../src/utils.tsx","../../src/features/ColumnSizing.ts","../../src/features/Expanding.ts","../../src/filterTypes.ts","../../src/features/Filters.ts","../../src/aggregationTypes.ts","../../src/features/Grouping.ts","../../src/features/Ordering.ts","../../src/features/Pagination.ts","../../src/features/Pinning.ts","../../src/features/RowSelection.ts","../../src/sortTypes.ts","../../src/features/Sorting.ts","../../src/features/Visibility.ts","../../src/features/Headers.ts","../../src/core.tsx","../../src/createTable.tsx","../../src/utils/filterRowsUtils.ts","../../src/utils/expandRowsFn.ts","../../src/utils/columnFilterRowsFn.ts","../../src/utils/globalFilterRowsFn.ts","../../src/utils/groupRowsFn.ts","../../src/utils/paginateRowsFn.ts","../../src/utils/sortRowsFn.ts"],"sourcesContent":["import { Getter, NoInfer, PropGetterValue, TableState, Updater } from './types'\n\nexport type IsAny<T> = 0 extends 1 & T ? true : false\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\nexport type RequiredKeys<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type Overwrite<T, U extends { [TKey in keyof T]?: any }> = Omit<\n  T,\n  keyof U\n> &\n  U\n\nexport type DataUpdateFunction<T> = (input: T) => T\n\nexport function functionalUpdate<T>(updater: Updater<T>, input: T): T {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<T>)(input)\n    : updater\n}\n\nexport function noop() {\n  //\n}\n\nexport function makeStateUpdater(key: keyof TableState, instance: unknown) {\n  return (updater: Updater<any>) => {\n    ;(instance as any).setState(<TTableState,>(old: TTableState) => {\n      return {\n        ...old,\n        [key]: functionalUpdate(updater, (old as any)[key]),\n      }\n    })\n  }\n}\n\ntype AnyFunction = (...args: any) => any\n\nexport function isFunction<T extends AnyFunction>(d: any): d is T {\n  return d instanceof Function\n}\n\nexport function flattenBy<TNode>(\n  arr: TNode[],\n  getChildren: (item: TNode) => TNode[]\n) {\n  const flat: TNode[] = []\n\n  const recurse = (subArr: TNode[]) => {\n    subArr.forEach(item => {\n      flat.push(item)\n      const children = getChildren(item)\n      if (children?.length) {\n        recurse(children)\n      }\n    })\n  }\n\n  recurse(arr)\n\n  return flat\n}\n\ntype PropGetterImpl = <TBaseProps, TGetter extends Getter<TBaseProps>>(\n  initial: TBaseProps,\n  userProps?: TGetter\n) => PropGetterValue<TBaseProps, TGetter>\n\n// @ts-ignore // Just rely on the type, not the implementation\nexport const propGetter: PropGetterImpl = (initial, getter) => {\n  if (isFunction(getter)) {\n    return getter(initial)\n  }\n\n  return {\n    ...initial,\n    ...(getter ?? {}),\n  }\n}\n\nexport function memo<TDeps extends readonly any[], TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: string\n    debug?: () => any\n    onChange?: (result: TResult, previousResult?: TResult) => void\n  }\n): () => TResult {\n  let deps: any[] = []\n  let result: TResult | undefined\n\n  return () => {\n    let depTime: number\n    if (opts.key && opts.debug) depTime = performance.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (depsChanged) {\n      let oldResult = result\n      let resultTime: number\n      if (opts.key && opts.debug) resultTime = performance.now()\n      result = fn(...newDeps)\n      deps = newDeps\n      opts?.onChange?.(result, oldResult)\n\n      if (opts.key && opts.debug) {\n        if (opts?.debug()) {\n          const depEndTime =\n            Math.round((performance.now() - depTime!) * 100) / 100\n          const resultEndTime =\n            Math.round((performance.now() - resultTime!) * 100) / 100\n          const resultFpsPercentage = resultEndTime / 16\n\n          const pad = (str: number | string, num: number) => {\n            str = String(str)\n            while (str.length < num) {\n              str = ' ' + str\n            }\n            return str\n          }\n\n          console.info(\n            `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n            `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120)\n            )}deg 100% 31%);`,\n            opts?.key,\n            {\n              length: `${deps.length} -> ${newDeps.length}`,\n              ...newDeps\n                .map((_, index) => {\n                  if (deps[index] !== newDeps[index]) {\n                    return [index, deps[index], newDeps[index]]\n                  }\n\n                  return false\n                })\n                .filter(Boolean)\n                .reduce(\n                  (accu, [a, b]: any) => ({\n                    ...accu,\n                    [a]: b,\n                  }),\n                  {}\n                ),\n              parent,\n            }\n          )\n        }\n      }\n\n      oldResult = undefined\n    }\n\n    return result!\n  }\n}\n\n// export function hashString(str: string, seed = 0): string {\n//   let h1 = 0xdeadbeef ^ seed,\n//     h2 = 0x41c6ce57 ^ seed\n//   for (let i = 0, ch; i < str.length; i++) {\n//     ch = str.charCodeAt(i)\n//     h1 = Math.imul(h1 ^ ch, 2654435761)\n//     h2 = Math.imul(h2 ^ ch, 1597334677)\n//   }\n//   h1 =\n//     Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^\n//     Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n//   h2 =\n//     Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^\n//     Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n//   return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString()\n// }\n","import {\n  Column,\n  Getter,\n  Header,\n  OnChangeFn,\n  AnyGenerics,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\n//\n\nexport type ColumnSizing = Record<string, number>\n\nexport type ColumnSizingInfoState = {\n  startOffset: null | number\n  startSize: null | number\n  deltaOffset: null | number\n  deltaPercentage: null | number\n  isResizingColumn: false | string\n  columnSizingStart: [string, number][]\n}\n\nexport type ColumnSizingTableState = {\n  columnSizing: ColumnSizing\n  columnSizingInfo: ColumnSizingInfoState\n}\n\nexport type ColumnResizeMode = 'onChange' | 'onEnd'\n\nexport type ColumnSizingOptions = {\n  enableColumnResizing?: boolean\n  columnResizeMode?: ColumnResizeMode\n  onColumnSizingChange?: OnChangeFn<ColumnSizing>\n  onColumnSizingInfoChange?: OnChangeFn<ColumnSizingInfoState>\n}\n\nexport type ColumnSizingDefaultOptions = {\n  columnResizeMode: ColumnResizeMode\n  onColumnSizingChange: OnChangeFn<ColumnSizing>\n  onColumnSizingInfoChange: OnChangeFn<ColumnSizingInfoState>\n}\n\nexport type ColumnResizerProps = {\n  title?: string\n  onMouseDown?: (e: MouseEvent) => void\n  onTouchStart?: (e: TouchEvent) => void\n  draggable?: boolean\n  role?: string\n}\n\nexport type ColumnSizingInstance<TGenerics extends AnyGenerics> = {\n  getColumnWidth: (columnId: string) => number\n  setColumnSizing: (updater: Updater<ColumnSizing>) => void\n  setColumnSizingInfo: (updater: Updater<ColumnSizingInfoState>) => void\n  resetColumnSizing: () => void\n  resetColumnSize: (columnId: string) => void\n  resetHeaderSize: (headerId: string) => void\n  resetHeaderSizeInfo: () => void\n  getColumnCanResize: (columnId: string) => boolean\n  getHeaderCanResize: (headerId: string) => boolean\n  getHeaderResizerProps: <TGetter extends Getter<ColumnResizerProps>>(\n    headerId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ColumnResizerProps, TGetter>\n  getColumnIsResizing: (columnId: string) => boolean\n  getHeaderIsResizing: (headerId: string) => boolean\n}\n\nexport type ColumnSizingColumnDef = {\n  enableResizing?: boolean\n  defaultCanResize?: boolean\n  width?: number\n  minWidth?: number\n  maxWidth?: number\n}\n\nexport type ColumnSizingColumn<TGenerics extends AnyGenerics> = {\n  getCanResize: () => boolean\n  getIsResizing: () => boolean\n  resetSize: () => void\n}\n\nexport type ColumnSizingHeader<TGenerics extends AnyGenerics> = {\n  getCanResize: () => boolean\n  getIsResizing: () => boolean\n  getResizerProps: <TGetter extends Getter<ColumnResizerProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ColumnResizerProps, TGetter>\n  resetSize: () => void\n}\n\n//\n\nexport const defaultColumnSizing = {\n  width: 150,\n  minWidth: 20,\n  maxWidth: Number.MAX_SAFE_INTEGER,\n}\n\nexport const ColumnSizing = {\n  getDefaultColumn: (): ColumnSizingColumnDef => {\n    return defaultColumnSizing\n  },\n  getInitialState: (): ColumnSizingTableState => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: {\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: [],\n      },\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingDefaultOptions => {\n    return {\n      columnResizeMode: 'onEnd',\n      onColumnSizingChange: makeStateUpdater('columnSizing', instance),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', instance),\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingInstance<TGenerics> => {\n    return {\n      getColumnWidth: (columnId: string) => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        const columnSize = instance.getState().columnSizing[column.id]\n\n        return Math.min(\n          Math.max(\n            column.minWidth ?? defaultColumnSizing.minWidth,\n            columnSize ?? column.width ?? defaultColumnSizing.width\n          ),\n          column.maxWidth ?? defaultColumnSizing.maxWidth\n        )\n      },\n      setColumnSizing: updater =>\n        instance.options.onColumnSizingChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnSizing)\n        ),\n      setColumnSizingInfo: updater =>\n        instance.options.onColumnSizingInfoChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnSizingInfo)\n        ),\n      resetColumnSizing: () => {\n        instance.setColumnSizing(instance.initialState.columnSizing ?? {})\n      },\n      resetHeaderSizeInfo: () => {\n        instance.setColumnSizingInfo(\n          instance.initialState.columnSizingInfo ?? {}\n        )\n      },\n      resetColumnSize: columnId => {\n        instance.setColumnSizing(({ [columnId]: _, ...rest }) => {\n          return rest\n        })\n      },\n      resetHeaderSize: headerId => {\n        const header = instance.getHeader(headerId)\n\n        return instance.resetColumnSize(header.column.id)\n      },\n      getHeaderCanResize: headerId => {\n        const header = instance.getHeader(headerId)\n\n        if (!header) {\n          throw new Error()\n        }\n\n        return instance.getColumnCanResize(header.column.id)\n      },\n      getColumnCanResize: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableResizing ??\n          instance.options.enableColumnResizing ??\n          column.defaultCanResize ??\n          true\n        )\n      },\n      getColumnIsResizing: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          instance.getState().columnSizingInfo.isResizingColumn === columnId\n        )\n      },\n      getHeaderIsResizing: headerId => {\n        const header = instance.getHeader(headerId)\n\n        if (!header) {\n          throw new Error()\n        }\n\n        return instance.getColumnIsResizing(header.column.id)\n      },\n\n      getHeaderResizerProps: (headerId, userProps) => {\n        const header = instance.getHeader(headerId)\n        const column = instance.getColumn(header.column.id)\n\n        const canResize = column.getCanResize()\n\n        const onResizeStart = (e: MouseEvent | TouchEvent) => {\n          if (isTouchStartEvent(e)) {\n            // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n            if (e.touches && e.touches.length > 1) {\n              return\n            }\n          }\n\n          const header = headerId ? instance.getHeader(headerId) : undefined\n\n          const startSize = header ? header.getWidth() : column.getWidth()\n\n          const columnSizingStart: [string, number][] = header\n            ? header.getLeafHeaders().map(d => [d.column.id, d.getWidth()])\n            : [[column.id, column.getWidth()]]\n\n          const clientX = isTouchStartEvent(e)\n            ? Math.round(e.touches[0].clientX)\n            : e.clientX\n\n          const updateOffset = (\n            eventType: 'move' | 'end',\n            clientXPos?: number\n          ) => {\n            if (typeof clientXPos !== 'number') {\n              return\n            }\n\n            let newColumnSizing: ColumnSizing = {}\n\n            instance.setColumnSizingInfo(old => {\n              const deltaOffset = clientXPos - (old?.startOffset ?? 0)\n              const deltaPercentage = Math.max(\n                deltaOffset / (old?.startSize ?? 0),\n                -0.999999\n              )\n\n              old.columnSizingStart.forEach(([columnId, headerWidth]) => {\n                newColumnSizing[columnId] =\n                  Math.round(\n                    Math.max(headerWidth + headerWidth * deltaPercentage, 0) *\n                      100\n                  ) / 100\n              })\n\n              return {\n                ...old,\n                deltaOffset,\n                deltaPercentage,\n              }\n            })\n\n            if (\n              instance.options.columnResizeMode === 'onChange' ||\n              eventType === 'end'\n            ) {\n              instance.setColumnSizing(old => ({\n                ...old,\n                ...newColumnSizing,\n              }))\n            }\n          }\n\n          const onMove = (clientXPos?: number) =>\n            updateOffset('move', clientXPos)\n\n          const onEnd = (clientXPos?: number) => {\n            updateOffset('end', clientXPos)\n\n            instance.setColumnSizingInfo(old => ({\n              ...old,\n              isResizingColumn: false,\n              startOffset: null,\n              startSize: null,\n              deltaOffset: null,\n              deltaPercentage: null,\n              columnSizingStart: [],\n            }))\n          }\n\n          const mouseEvents = {\n            moveHandler: (e: MouseEvent) => onMove(e.clientX),\n            upHandler: (e: MouseEvent) => {\n              document.removeEventListener('mousemove', mouseEvents.moveHandler)\n              document.removeEventListener('mouseup', mouseEvents.upHandler)\n              onEnd(e.clientX)\n            },\n          }\n\n          const touchEvents = {\n            moveHandler: (e: TouchEvent) => {\n              if (e.cancelable) {\n                e.preventDefault()\n                e.stopPropagation()\n              }\n              onMove(e.touches[0].clientX)\n              return false\n            },\n            upHandler: (e: TouchEvent) => {\n              document.removeEventListener('touchmove', touchEvents.moveHandler)\n              document.removeEventListener('touchend', touchEvents.upHandler)\n              if (e.cancelable) {\n                e.preventDefault()\n                e.stopPropagation()\n              }\n              onEnd(e.touches[0].clientX)\n            },\n          }\n\n          const passiveIfSupported = passiveEventSupported()\n            ? { passive: false }\n            : false\n\n          if (isTouchStartEvent(e)) {\n            document.addEventListener(\n              'touchmove',\n              touchEvents.moveHandler,\n              passiveIfSupported\n            )\n            document.addEventListener(\n              'touchend',\n              touchEvents.upHandler,\n              passiveIfSupported\n            )\n          } else {\n            document.addEventListener(\n              'mousemove',\n              mouseEvents.moveHandler,\n              passiveIfSupported\n            )\n            document.addEventListener(\n              'mouseup',\n              mouseEvents.upHandler,\n              passiveIfSupported\n            )\n          }\n\n          instance.setColumnSizingInfo(old => ({\n            ...old,\n            startOffset: clientX,\n            startSize,\n            deltaOffset: 0,\n            deltaPercentage: 0,\n            columnSizingStart,\n            isResizingColumn: column.id,\n          }))\n        }\n\n        const initialProps: ColumnResizerProps = canResize\n          ? {\n              title: 'Toggle Grouping',\n              draggable: false,\n              role: 'separator',\n              onMouseDown: (e: MouseEvent & { persist?: () => void }) => {\n                e.persist?.()\n                onResizeStart(e)\n              },\n              onTouchStart: (e: TouchEvent & { persist?: () => void }) => {\n                e.persist?.()\n                onResizeStart(e)\n              },\n            }\n          : {}\n\n        return propGetter(initialProps, userProps)\n      },\n    }\n  },\n\n  createColumn: <TGenerics extends AnyGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingColumn<TGenerics> => {\n    return {\n      getIsResizing: () => instance.getColumnIsResizing(column.id),\n      getCanResize: () => instance.getColumnCanResize(column.id),\n      resetSize: () => instance.resetColumnSize(column.id),\n    }\n  },\n\n  createHeader: <TGenerics extends AnyGenerics>(\n    header: Header<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingHeader<TGenerics> => {\n    return {\n      getIsResizing: () => instance.getColumnIsResizing(header.column.id),\n      getCanResize: () => instance.getColumnCanResize(header.column.id),\n      resetSize: () => instance.resetColumnSize(header.column.id),\n      getResizerProps: userProps =>\n        instance.getHeaderResizerProps(header.id, userProps),\n    }\n  },\n}\n\nlet passiveSupported: boolean | null = null\nexport function passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported\n\n  let supported = false\n  try {\n    const options = {\n      get passive() {\n        supported = true\n        return false\n      },\n    }\n\n    const noop = () => {}\n\n    window.addEventListener('test', noop, options)\n    window.removeEventListener('test', noop)\n  } catch (err) {\n    supported = false\n  }\n  passiveSupported = supported\n  return passiveSupported\n}\n\nfunction isTouchStartEvent(e: TouchEvent | MouseEvent): e is TouchEvent {\n  return e.type === 'touchstart'\n}\n","import { MouseEvent, TouchEvent } from 'react'\nimport { RowModel } from '..'\nimport {\n  Getter,\n  OnChangeFn,\n  AnyGenerics,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Row,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\nexport type ExpandedStateList = Record<string, boolean>\nexport type ExpandedState = true | Record<string, boolean>\nexport type ExpandedTableState = {\n  expanded: ExpandedState\n}\n\nexport type ExpandedRow = {\n  toggleExpanded: (expanded?: boolean) => void\n  getIsExpanded: () => boolean\n  getCanExpand: () => boolean\n  getToggleExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n}\n\nexport type ExpandedOptions<TGenerics extends AnyGenerics> = {\n  onExpandedChange?: OnChangeFn<ExpandedState>\n  autoResetExpanded?: boolean\n  enableExpanded?: boolean\n  expandRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n  expandSubRows?: boolean\n  defaultCanExpand?: boolean\n  getIsRowExpanded?: (row: Row<TGenerics>) => boolean\n  getRowCanExpand?: (row: Row<TGenerics>) => boolean\n  paginateExpandedRows?: boolean\n}\n\nexport type ToggleExpandedProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type ExpandedInstance<TGenerics extends AnyGenerics> = {\n  _notifyExpandedReset: () => void\n  setExpanded: (updater: Updater<ExpandedState>) => void\n  toggleRowExpanded: (rowId: string, expanded?: boolean) => void\n  toggleAllRowsExpanded: (expanded?: boolean) => void\n  resetExpanded: () => void\n  getRowCanExpand: (rowId: string) => boolean\n  getIsRowExpanded: (rowId: string) => boolean\n  getToggleExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    rowId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n  getToggleAllRowsExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n  getIsSomeRowsExpanded: () => boolean\n  getIsAllRowsExpanded: () => boolean\n  getExpandedDepth: () => number\n  getExpandedRowModel: () => RowModel<TGenerics>\n  getPreExpandedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Expanding = {\n  getInitialState: (): ExpandedTableState => {\n    return {\n      expanded: {},\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ExpandedOptions<TGenerics> => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', instance),\n      autoResetExpanded: true,\n      expandSubRows: true,\n      paginateExpandedRows: true,\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ExpandedInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      _notifyExpandedReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetExpanded\n        ) {\n          instance.resetExpanded()\n        }\n      },\n      setExpanded: updater =>\n        instance.options.onExpandedChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().expanded)\n        ),\n      toggleRowExpanded: (rowId, expanded) => {\n        if (!rowId) return\n\n        instance.setExpanded(old => {\n          const exists = old === true ? true : !!old?.[rowId]\n\n          let oldExpanded: ExpandedStateList = {}\n\n          if (old === true) {\n            Object.keys(instance.getRowModel().rowsById).forEach(rowId => {\n              oldExpanded[rowId] = true\n            })\n          } else {\n            oldExpanded = old\n          }\n\n          expanded = expanded ?? !exists\n\n          if (!exists && expanded) {\n            return {\n              ...oldExpanded,\n              [rowId]: true,\n            }\n          }\n\n          if (exists && !expanded) {\n            const { [rowId]: _, ...rest } = oldExpanded\n            return rest\n          }\n\n          return old\n        })\n      },\n      toggleAllRowsExpanded: expanded => {\n        if (expanded ?? !instance.getIsAllRowsExpanded()) {\n          instance.setExpanded(true)\n        } else {\n          instance.setExpanded({})\n        }\n      },\n      resetExpanded: () => {\n        instance.setExpanded(instance.initialState?.expanded ?? {})\n      },\n      getIsRowExpanded: rowId => {\n        const row = instance.getPreExpandedRowModel().rowsById[rowId]\n\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `[Table] getIsRowExpanded: no row found with id ${rowId}`\n            )\n          }\n          throw new Error()\n        }\n\n        const expanded = instance.getState().expanded\n\n        return !!(\n          instance.options.getIsRowExpanded?.(row) ??\n          (expanded === true || expanded?.[rowId])\n        )\n      },\n      getRowCanExpand: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `[Table] getRowCanExpand: no row found with id ${rowId}`\n            )\n          }\n          throw new Error()\n        }\n\n        return (\n          instance.options.getRowCanExpand?.(row) ??\n          instance.options.enableExpanded ??\n          instance.options.defaultCanExpand ??\n          !!row.subRows?.length\n        )\n      },\n      getToggleExpandedProps: (rowId, userProps) => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          return\n        }\n\n        const canExpand = instance.getRowCanExpand(rowId)\n\n        const initialProps: ToggleExpandedProps = {\n          title: canExpand ? 'Toggle Expanded' : undefined,\n          onClick: canExpand\n            ? (e: MouseEvent | TouchEvent) => {\n                e.persist()\n                instance.toggleRowExpanded(rowId)\n              }\n            : undefined,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n      getToggleAllRowsExpandedProps: userProps => {\n        const initialProps: ToggleExpandedProps = {\n          title: 'Toggle All Expanded',\n          onClick: (e: MouseEvent | TouchEvent) => {\n            e.persist()\n            instance.toggleAllRowsExpanded()\n          },\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n      getIsSomeRowsExpanded: () => {\n        const expanded = instance.getState().expanded\n        return expanded === true || Object.values(expanded).some(Boolean)\n      },\n      getIsAllRowsExpanded: () => {\n        const expanded = instance.getState().expanded\n\n        // If expanded is true, save some cycles and return true\n        if (expanded === true) {\n          return true\n        }\n\n        // If any row is not expanded, return false\n        if (\n          Object.keys(instance.getRowModel().rowsById).some(\n            id => !instance.getIsRowExpanded(id)\n          )\n        ) {\n          return false\n        }\n\n        // They must all be expanded :shrug:\n        return true\n      },\n      getExpandedDepth: () => {\n        let maxDepth = 0\n\n        const rowIds =\n          instance.getState().expanded === true\n            ? Object.keys(instance.getRowModel().rowsById)\n            : Object.keys(instance.getState().expanded)\n\n        rowIds.forEach(id => {\n          const splitId = id.split('.')\n          maxDepth = Math.max(maxDepth, splitId.length)\n        })\n\n        return maxDepth\n      },\n      getExpandedRowModel: memo(\n        () => [\n          instance.getState().expanded,\n          instance.getGroupedRowModel(),\n          instance.options.expandRowsFn,\n          instance.options.paginateExpandedRows,\n        ],\n        (expanded, rowModel, expandRowsFn, paginateExpandedRows) => {\n          if (\n            !expandRowsFn ||\n            // Do not expand if rows are not included in pagination\n            !paginateExpandedRows ||\n            (expanded !== true && !Object.keys(expanded ?? {}).length)\n          ) {\n            return rowModel\n          }\n\n          return expandRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getExpandedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      getPreExpandedRowModel: () => instance.getGroupedRowModel(),\n    }\n  },\n\n  createRow: <TGenerics extends AnyGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ExpandedRow => {\n    return {\n      toggleExpanded: expanded =>\n        void instance.toggleRowExpanded(row.id, expanded),\n      getIsExpanded: () => instance.getIsRowExpanded(row.id),\n      getCanExpand: () => row.subRows && !!row.subRows.length,\n      getToggleExpandedProps: userProps =>\n        instance.getToggleExpandedProps(row.id, userProps),\n    }\n  },\n}\n","import { PartialGenerics, AnyGenerics, Row } from './types'\n\nexport const filterTypes = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  equalsStringSensitive,\n  arrIncludes,\n  arrIncludesAll,\n  equals,\n  weakEquals,\n  betweenNumberRange,\n}\n\nexport type BuiltInFilterType = keyof typeof filterTypes\n\nfunction includesString<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue).toLowerCase()\n\n  rows = rows.filter(row => {\n    return columnIds.some(id => {\n      return String(row.values[id]).toLowerCase().includes(search)\n    })\n  })\n  return rows\n}\n\nincludesString.autoRemove = (val: any) => testFalsey(val)\n\nfunction includesStringSensitive<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue)\n\n  rows = rows.filter(row => {\n    return columnIds.some(id => {\n      return String(row.values[id]).includes(search)\n    })\n  })\n  return rows\n}\n\nincludesStringSensitive.autoRemove = (val: any) => testFalsey(val)\n\nfunction equalsString<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue).toLowerCase()\n\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue !== undefined\n        ? String(rowValue).toLowerCase() === search\n        : true\n    })\n  })\n}\n\nequalsString.autoRemove = (val: any) => testFalsey(val)\n\nfunction equalsStringSensitive<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue)\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue !== undefined ? String(rowValue) === search : true\n    })\n  })\n}\n\nequalsStringSensitive.autoRemove = (val: any) => testFalsey(val)\n\nfunction arrIncludes<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue.includes(filterValue)\n    })\n  })\n}\n\narrIncludes.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nfunction arrIncludesAll<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown[]\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return (\n        rowValue &&\n        rowValue.length &&\n        filterValue.every(val => rowValue.includes(val))\n      )\n    })\n  })\n}\n\narrIncludesAll.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nfunction equals<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue === filterValue\n    })\n  })\n}\n\nequals.autoRemove = (val: any) => testFalsey(val)\n\nfunction weakEquals<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      // eslint-disable-next-line eqeqeq\n      return rowValue == filterValue\n    })\n  })\n}\n\nweakEquals.autoRemove = (val: any) => testFalsey(val)\n\nfunction betweenNumberRange<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: [unknown, unknown]\n) {\n  let [unsafeMin, unsafeMax] = filterValue || []\n\n  let parsedMin =\n    typeof unsafeMin !== 'number' ? parseFloat(unsafeMin as string) : unsafeMin\n  let parsedMax =\n    typeof unsafeMax !== 'number' ? parseFloat(unsafeMax as string) : unsafeMax\n\n  let min =\n    unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax\n\n  if (min > max) {\n    const temp = min\n    min = max\n    max = temp\n  }\n\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue >= min && rowValue <= max\n    })\n  })\n}\n\nbetweenNumberRange.autoRemove = (val: any) =>\n  testFalsey(val) || (testFalsey(val[0]) && testFalsey(val[1]))\n\n// Utils\n\nfunction testFalsey(val: any) {\n  return val === undefined || val === null || val === ''\n}\n","import { RowModel } from '..'\nimport { BuiltInFilterType, filterTypes } from '../filterTypes'\nimport {\n  Column,\n  OnChangeFn,\n  AnyGenerics,\n  PartialGenerics,\n  TableInstance,\n  Row,\n  Updater,\n} from '../types'\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  Overwrite,\n} from '../utils'\n\nexport type ColumnFilter = {\n  id: string\n  value: unknown\n}\n\nexport type ColumnFiltersState = ColumnFilter[]\n\nexport type FilterFn<TGenerics extends AnyGenerics> = {\n  (rows: Row<TGenerics>[], columnIds: string[], filterValue: any): any\n  autoRemove?: ColumnFilterAutoRemoveTestFn<TGenerics>\n}\n\nexport type ColumnFilterAutoRemoveTestFn<TGenerics extends AnyGenerics> = (\n  value: unknown,\n  column?: Column<TGenerics>\n) => boolean\n\nexport type CustomFilterTypes<TGenerics extends AnyGenerics> = Record<\n  string,\n  FilterFn<TGenerics>\n>\n\nexport type FiltersTableState = {\n  columnFilters: ColumnFiltersState\n  globalFilter: any\n}\n\nexport type FilterType<TGenerics extends AnyGenerics> =\n  | 'auto'\n  | BuiltInFilterType\n  | TGenerics['FilterFns']\n  | FilterFn<TGenerics>\n\nexport type FiltersColumnDef<TGenerics extends AnyGenerics> = {\n  filterType?: FilterType<Overwrite<TGenerics, { Value: any }>>\n  enableAllFilters?: boolean\n  enableColumnFilter?: boolean\n  enableGlobalFilter?: boolean\n  defaultCanFilter?: boolean\n  defaultCanColumnFilter?: boolean\n  defaultCanGlobalFilter?: boolean\n}\n\nexport type FiltersColumn<TGenerics extends AnyGenerics> = {\n  filterType: FilterType<Overwrite<TGenerics, { Value: any }>>\n  getCanColumnFilter: () => boolean\n  getCanGlobalFilter: () => boolean\n  getColumnFilterIndex: () => number\n  getIsColumnFiltered: () => boolean\n  getColumnFilterValue: () => unknown\n  setColumnFilterValue: (value: any) => void\n  getPreFilteredRows: () => Row<TGenerics>[] | undefined\n  getPreFilteredUniqueValues: () => Map<any, number>\n  getPreFilteredMinMaxValues: () => [any, any]\n}\n\nexport type FiltersOptions<TGenerics extends AnyGenerics> = {\n  filterFromLeafRows?: boolean\n  filterTypes?: TGenerics['FilterFns']\n  enableFilters?: boolean\n  // Column\n  onColumnFiltersChange?: OnChangeFn<ColumnFiltersState>\n  autoResetColumnFilters?: boolean\n  enableColumnFilters?: boolean\n  columnFilterRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    coreRowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n  // Global\n  globalFilterType?: FilterType<TGenerics>\n  onGlobalFilterChange?: OnChangeFn<any>\n  enableGlobalFilters?: boolean\n  autoResetGlobalFilter?: boolean\n  enableGlobalFilter?: boolean\n  globalFilterRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n  getColumnCanGlobalFilterFn?: (column: Column<TGenerics>) => boolean\n}\n\nexport type FiltersInstance<TGenerics extends AnyGenerics> = {\n  _notifyFiltersReset: () => void\n  getColumnAutoFilterFn: (columnId: string) => FilterFn<TGenerics> | undefined\n\n  getColumnFilterFn: (columnId: string) => FilterFn<TGenerics> | undefined\n\n  setColumnFilters: (updater: Updater<ColumnFiltersState>) => void\n  setColumnFilterValue: (columnId: string, value: any) => void\n  resetColumnFilters: () => void\n  getColumnCanColumnFilter: (columnId: string) => boolean\n  getColumnCanGlobalFilterFn?: (column: Column<TGenerics>) => boolean\n\n  getColumnIsFiltered: (columnId: string) => boolean\n  getColumnFilterValue: (columnId: string) => unknown\n  getColumnFilterIndex: (columnId: string) => number\n\n  // All\n  getPreFilteredRowModel: () => RowModel<TGenerics>\n\n  // Column Filters\n  getPreColumnFilteredRowModel: () => RowModel<TGenerics>\n  getColumnFilteredRowModel: () => RowModel<TGenerics>\n\n  // Global Filters\n  setGlobalFilter: (updater: Updater<any>) => void\n  resetGlobalFilter: () => void\n  getGlobalAutoFilterFn: () => FilterFn<TGenerics> | undefined\n  getGlobalFilterFn: () => FilterFn<TGenerics> | undefined\n  getColumnCanGlobalFilter: (columnId: string) => boolean\n  getPreGlobalFilteredRowModel: () => RowModel<TGenerics>\n  getGlobalFilteredRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Filters = {\n  getDefaultColumn: <\n    TGenerics extends AnyGenerics\n  >(): FiltersColumnDef<TGenerics> => {\n    return {\n      filterType: 'auto',\n    }\n  },\n\n  getInitialState: (): FiltersTableState => {\n    return {\n      columnFilters: [],\n      globalFilter: undefined,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): FiltersOptions<TGenerics> => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', instance),\n      onGlobalFilterChange: makeStateUpdater('globalFilter', instance),\n      autoResetColumnFilters: true,\n      filterFromLeafRows: true,\n      autoResetGlobalFilter: true,\n      globalFilterType: 'auto',\n      getColumnCanGlobalFilterFn: column => {\n        const value = instance\n          .getCoreRowModel()\n          .flatRows[0]?.getAllCellsByColumnId()[column.id]?.value\n\n        return typeof value === 'string'\n      },\n    }\n  },\n\n  createColumn: <TGenerics extends AnyGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): FiltersColumn<TGenerics> => {\n    const getFacetInfo = memo(\n      () => [column.getPreFilteredRows()],\n      (rows = []) => {\n        let preFilteredUniqueValues = new Map<any, number>()\n\n        let preFilteredMinMaxValues: [any, any] = [\n          rows[0]?.values[column.id] ?? null,\n          rows[0]?.values[column.id] ?? null,\n        ]\n\n        for (let i = 0; i < rows.length; i++) {\n          const value = rows[i]?.values[column.id]\n\n          if (preFilteredUniqueValues.has(value)) {\n            preFilteredUniqueValues.set(\n              value,\n              (preFilteredUniqueValues.get(value) ?? 0) + 1\n            )\n          } else {\n            preFilteredUniqueValues.set(value, 1)\n          }\n\n          if (value < preFilteredMinMaxValues[0]) {\n            preFilteredMinMaxValues[0] = value\n          } else if (value > preFilteredMinMaxValues[1]) {\n            preFilteredMinMaxValues[1] = value\n          }\n        }\n\n        return {\n          preFilteredUniqueValues,\n          preFilteredMinMaxValues,\n        }\n      },\n      {\n        key: 'column.getFacetInfo',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    )\n\n    return {\n      filterType: column.filterType,\n      getCanColumnFilter: () => instance.getColumnCanColumnFilter(column.id),\n      getCanGlobalFilter: () => instance.getColumnCanGlobalFilter(column.id),\n      getColumnFilterIndex: () => instance.getColumnFilterIndex(column.id),\n      getIsColumnFiltered: () => instance.getColumnIsFiltered(column.id),\n      getColumnFilterValue: () => instance.getColumnFilterValue(column.id),\n      setColumnFilterValue: val =>\n        instance.setColumnFilterValue(column.id, val),\n      getPreFilteredUniqueValues: () => getFacetInfo().preFilteredUniqueValues,\n      getPreFilteredMinMaxValues: () => getFacetInfo().preFilteredMinMaxValues,\n      getPreFilteredRows: () => undefined,\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): FiltersInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      _notifyFiltersReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (instance.options.autoResetAll === true) {\n          instance.resetSorting()\n        } else {\n          if (instance.options.autoResetColumnFilters) {\n            instance.resetColumnFilters()\n          }\n          if (instance.options.autoResetGlobalFilter) {\n            instance.resetGlobalFilter()\n          }\n        }\n      },\n      getColumnAutoFilterFn: columnId => {\n        const firstRow = instance.getCoreRowModel().flatRows[0]\n\n        const value = firstRow?.values[columnId]\n\n        if (typeof value === 'string') {\n          return filterTypes.includesString\n        }\n\n        if (typeof value === 'number') {\n          return filterTypes.betweenNumberRange\n        }\n\n        if (value !== null && typeof value === 'object') {\n          return filterTypes.equals\n        }\n\n        if (Array.isArray(value)) {\n          return filterTypes.arrIncludes\n        }\n\n        return filterTypes.weakEquals\n      },\n      getGlobalAutoFilterFn: () => {\n        return filterTypes.includesString\n      },\n      getColumnFilterFn: columnId => {\n        const column = instance.getColumn(columnId)\n        const userFilterTypes = instance.options.filterTypes\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return isFunction(column.filterType)\n          ? column.filterType\n          : column.filterType === 'auto'\n          ? instance.getColumnAutoFilterFn(columnId)\n          : (userFilterTypes as Record<string, any>)?.[\n              column.filterType as string\n            ] ??\n            (filterTypes[\n              column.filterType as BuiltInFilterType\n            ] as FilterFn<TGenerics>)\n      },\n\n      getGlobalFilterFn: () => {\n        const { filterTypes: userFilterTypes, globalFilterType } =\n          instance.options\n\n        return isFunction(globalFilterType)\n          ? globalFilterType\n          : globalFilterType === 'auto'\n          ? instance.getGlobalAutoFilterFn()\n          : (userFilterTypes as Record<string, any>)?.[\n              globalFilterType as string\n            ] ??\n            (filterTypes[\n              globalFilterType as BuiltInFilterType\n            ] as FilterFn<TGenerics>)\n      },\n\n      setColumnFilters: (updater: Updater<ColumnFiltersState>) => {\n        const leafColumns = instance.getAllLeafColumns()\n\n        const updateFn = (old: ColumnFiltersState) => {\n          return functionalUpdate(updater, old)?.filter(filter => {\n            const column = leafColumns.find(d => d.id === filter.id)\n\n            if (column) {\n              const filterFn = instance.getColumnFilterFn(column.id)\n\n              if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                return false\n              }\n            }\n\n            return true\n          })\n        }\n\n        instance.options.onColumnFiltersChange?.(\n          updateFn,\n          updateFn(instance.getState().columnFilters)\n        )\n      },\n\n      setGlobalFilter: updater => {\n        instance.options.onGlobalFilterChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().globalFilter)\n        )\n      },\n\n      resetGlobalFilter: () => {\n        instance.setGlobalFilter(undefined)\n      },\n\n      getColumnCanColumnFilter: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableAllFilters ??\n          column.enableColumnFilter ??\n          instance.options.enableFilters ??\n          instance.options.enableColumnFilters ??\n          column.defaultCanFilter ??\n          column.defaultCanColumnFilter ??\n          !!column.accessorFn\n        )\n      },\n\n      getColumnCanGlobalFilter: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          ((instance.options.enableFilters ??\n            instance.options.enableGlobalFilter ??\n            column.enableAllFilters ??\n            column.enableGlobalFilter ??\n            column.defaultCanFilter ??\n            column.defaultCanGlobalFilter ??\n            !!column.accessorFn) &&\n            instance.options.getColumnCanGlobalFilterFn?.(column)) ??\n          true\n        )\n      },\n\n      getColumnIsFiltered: columnId =>\n        instance.getColumnFilterIndex(columnId) > -1,\n\n      getColumnFilterValue: columnId =>\n        instance.getState().columnFilters?.find(d => d.id === columnId)?.value,\n\n      getColumnFilterIndex: columnId =>\n        instance.getState().columnFilters?.findIndex(d => d.id === columnId) ??\n        -1,\n\n      setColumnFilterValue: (columnId, value) => {\n        if (!columnId) return\n\n        instance.setColumnFilters(old => {\n          const column = instance.getColumn(columnId)\n\n          if (!column) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn(\n                `Table: Could not find a column with id: ${columnId}`\n              )\n            }\n            throw new Error()\n          }\n\n          const filterFn = instance.getColumnFilterFn(column.id)\n          const previousfilter = old?.find(d => d.id === columnId)\n\n          const newFilter = functionalUpdate(\n            value,\n            previousfilter ? previousfilter.value : undefined\n          )\n\n          //\n          if (\n            shouldAutoRemoveFilter(\n              filterFn as FilterFn<TGenerics>,\n              newFilter,\n              column\n            )\n          ) {\n            return old?.filter(d => d.id !== columnId) ?? []\n          }\n\n          const newFilterObj = { id: columnId, value: newFilter }\n\n          if (previousfilter) {\n            return (\n              old?.map(d => {\n                if (d.id === columnId) {\n                  return newFilterObj\n                }\n                return d\n              }) ?? []\n            )\n          }\n\n          if (old?.length) {\n            return [...old, newFilterObj]\n          }\n\n          return [newFilterObj]\n        })\n      },\n\n      resetColumnFilters: () => {\n        instance.setColumnFilters(instance.initialState?.columnFilters ?? [])\n      },\n\n      getPreFilteredRowModel: () => instance.getCoreRowModel(),\n      getPreColumnFilteredRowModel: () => instance.getCoreRowModel(),\n      getColumnFilteredRowModel: memo(\n        () => [\n          instance.getState().columnFilters,\n          instance.getCoreRowModel(),\n          instance.options.columnFilterRowsFn,\n        ],\n        (columnFilters, rowModel, columnFiltersFn) => {\n          const columnFilteredRowModel = (() => {\n            if (!columnFilters?.length || !columnFiltersFn) {\n              return rowModel\n            }\n\n            return columnFiltersFn(instance as any, rowModel)\n          })()\n\n          // Now that each filtered column has it's partially filtered rows,\n          // lets assign the final filtered rows to all of the other columns\n          const nonFilteredColumns = instance\n            .getAllLeafColumns()\n            .filter(\n              column =>\n                !instance\n                  .getState()\n                  .columnFilters?.find(d => d.id === column.id)\n            )\n\n          // This essentially enables faceted filter options to be built easily\n          // using every column's preFilteredRows value\n\n          nonFilteredColumns.forEach(column => {\n            column.getPreFilteredRows = () => columnFilteredRowModel.rows\n          })\n\n          return columnFilteredRowModel\n        },\n        {\n          key: 'getColumnFilteredRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n      getPreGlobalFilteredRowModel: () => instance.getColumnFilteredRowModel(),\n      getGlobalFilteredRowModel: memo(\n        () => [\n          instance.getState().globalFilter,\n          instance.getColumnFilteredRowModel(),\n          instance.options.globalFilterRowsFn,\n        ],\n        (globalFilterValue, columnFilteredRowModel, globalFiltersFn) => {\n          const globalFilteredRowModel = (() => {\n            if (!globalFiltersFn || !globalFilterValue) {\n              return columnFilteredRowModel\n            }\n\n            return globalFiltersFn(\n              instance as TableInstance<TGenerics>,\n              columnFilteredRowModel\n            )\n          })()\n\n          // Now that each filtered column has it's partially filtered rows,\n          // lets assign the final filtered rows to all of the other columns\n          const nonFilteredColumns = instance\n            .getAllLeafColumns()\n            .filter(\n              column =>\n                !instance\n                  .getState()\n                  .columnFilters?.find(d => d.id === column.id)\n            )\n\n          // This essentially enables faceted filter options to be built easily\n          // using every column's preFilteredRows value\n\n          nonFilteredColumns.forEach(column => {\n            column.getPreFilteredRows = () => globalFilteredRowModel.rows\n          })\n\n          return globalFilteredRowModel\n        },\n        {\n          key: 'getGlobalFilteredRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => {\n            instance._notifySortingReset()\n          },\n        }\n      ),\n    }\n  },\n}\n\nexport function shouldAutoRemoveFilter<TGenerics extends AnyGenerics>(\n  filterFn?: FilterFn<TGenerics>,\n  value?: any,\n  column?: Column<TGenerics>\n) {\n  return (\n    (filterFn && filterFn.autoRemove\n      ? filterFn.autoRemove(value, column)\n      : false) ||\n    typeof value === 'undefined' ||\n    (typeof value === 'string' && !value)\n  )\n}\n","export const aggregationTypes = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count,\n}\n\nexport type BuiltInAggregationType = keyof typeof aggregationTypes\n\nfunction sum(_getLeafValues: () => unknown[], getChildValues: () => unknown[]) {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return getChildValues().reduce(\n    (sum: number, next: unknown) => sum + (typeof next === 'number' ? next : 0),\n    0\n  )\n}\n\nfunction min(_getLeafValues: () => unknown[], getChildValues: () => unknown[]) {\n  let min: number | undefined\n\n  for (const value of getChildValues() as number[]) {\n    if (\n      value != null &&\n      (min! > value || (min === undefined && value >= value))\n    ) {\n      min = value\n    }\n  }\n\n  return min\n}\n\nfunction max(_getLeafValues: () => unknown[], getChildValues: () => unknown[]) {\n  let max: number | undefined\n\n  for (const value of getChildValues() as number[]) {\n    if (\n      value != null &&\n      (max! < value || (max === undefined && value >= value))\n    ) {\n      max = value\n    }\n  }\n\n  return max\n}\n\nfunction extent(\n  _getLeafValues: () => unknown[],\n  getChildValues: () => unknown[]\n) {\n  let min: number | undefined\n  let max: number | undefined\n\n  for (const value of getChildValues() as number[]) {\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value\n      } else {\n        if (min > value) min = value\n        if (max! < value) max = value\n      }\n    }\n  }\n\n  return [min, max]\n}\n\nfunction mean(getLeafValues: () => unknown[]) {\n  let count = 0\n  let sum = 0\n\n  for (let value of getLeafValues() as number[]) {\n    if (value != null && (value = +value) >= value) {\n      ++count, (sum += value)\n    }\n  }\n\n  if (count) return sum / count\n\n  return\n}\n\nfunction median(getLeafValues: () => unknown[]) {\n  const leafValues = getLeafValues()\n  if (!leafValues.length) {\n    return\n  }\n\n  let min = 0\n  let max = 0\n\n  leafValues.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value)\n      max = Math.max(max, value)\n    }\n  })\n\n  return (min + max) / 2\n}\n\nfunction unique<T>(getLeafValues: () => T[]) {\n  return Array.from(new Set(getLeafValues()).values())\n}\n\nfunction uniqueCount(getLeafValues: () => unknown[]) {\n  return new Set(getLeafValues()).size\n}\n\nfunction count(getLeafValues: () => unknown[]) {\n  return getLeafValues().length\n}\n","import { RowModel } from '..'\nimport { BuiltInAggregationType, aggregationTypes } from '../aggregationTypes'\nimport {\n  Cell,\n  Column,\n  Getter,\n  OnChangeFn,\n  PropGetterValue,\n  TableInstance,\n  Row,\n  Updater,\n  PartialGenerics,\n  Renderable,\n  UseRenderer,\n  AnyGenerics,\n} from '../types'\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  Overwrite,\n  propGetter,\n} from '../utils'\n\nexport type GroupingState = string[]\n\nexport type AggregationFn<TGenerics extends AnyGenerics> = (\n  getLeafValues: () => TGenerics['Row'][],\n  getChildValues: () => TGenerics['Row'][]\n) => any\n\nexport type CustomAggregationTypes<TGenerics extends AnyGenerics> = Record<\n  string,\n  AggregationFn<TGenerics>\n>\n\nexport type AggregationType<TGenerics extends AnyGenerics> =\n  | 'auto'\n  | BuiltInAggregationType\n  | keyof TGenerics['AggregationFns']\n  | AggregationFn<TGenerics>\n\nexport type GroupingTableState = {\n  grouping: GroupingState\n}\n\nexport type GroupingColumnDef<TGenerics extends AnyGenerics> = {\n  aggregationType?: AggregationType<Overwrite<TGenerics, { Value: any }>>\n  aggregateValue?: (columnValue: unknown) => any\n  aggregatedCell?: Renderable<\n    TGenerics,\n    {\n      instance: TableInstance<TGenerics>\n      row: Row<TGenerics>\n      column: Column<TGenerics>\n      cell: Cell<TGenerics>\n      value: TGenerics['Value']\n    }\n  >\n  enableGrouping?: boolean\n  defaultCanGroup?: boolean\n}\n\nexport type GroupingColumn<TGenerics extends AnyGenerics> = {\n  aggregationType?: AggregationType<Overwrite<TGenerics, { Value: any }>>\n  getCanGroup: () => boolean\n  getIsGrouped: () => boolean\n  getGroupedIndex: () => number\n  toggleGrouping: () => void\n  getToggleGroupingProps: <TGetter extends Getter<ToggleGroupingProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleGroupingProps, TGetter>\n}\n\nexport type GroupingRow = {\n  groupingColumnId?: string\n  groupingValue?: any\n  getIsGrouped: () => boolean\n}\n\nexport type GroupingCell<TGenerics extends AnyGenerics> = {\n  getIsGrouped: () => boolean\n  getIsPlaceholder: () => boolean\n  getIsAggregated: () => boolean\n  renderAggregatedCell: () => string | null | ReturnType<UseRenderer<TGenerics>>\n}\n\nexport type ColumnDefaultOptions = {\n  // Column\n  onGroupingChange: OnChangeFn<GroupingState>\n  autoResetGrouping: boolean\n  enableGrouping: boolean\n}\n\nexport type GroupingOptions<TGenerics extends AnyGenerics> = {\n  aggregationTypes?: TGenerics['AggregationFns']\n  onGroupingChange?: OnChangeFn<GroupingState>\n  autoResetGrouping?: boolean\n  enableGrouping?: boolean\n  enableGroupingRemoval?: boolean\n  groupRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n\n  groupedColumnMode?: false | 'reorder' | 'remove'\n}\n\nexport type GroupingColumnMode = false | 'reorder' | 'remove'\n\nexport type ToggleGroupingProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type GroupingInstance<TGenerics extends AnyGenerics> = {\n  _notifyGroupingReset: () => void\n  getColumnAutoAggregationFn: (\n    columnId: string\n  ) => AggregationFn<TGenerics> | undefined\n  getColumnAggregationFn: (\n    columnId: string\n  ) => AggregationFn<TGenerics> | undefined\n  setGrouping: (updater: Updater<GroupingState>) => void\n  resetGrouping: () => void\n  toggleColumnGrouping: (columnId: string) => void\n  getColumnCanGroup: (columnId: string) => boolean\n  getColumnIsGrouped: (columnId: string) => boolean\n  getColumnGroupedIndex: (columnId: string) => number\n  getToggleGroupingProps: <TGetter extends Getter<ToggleGroupingProps>>(\n    columnId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleGroupingProps, TGetter>\n  getRowIsGrouped: (rowId: string) => boolean\n  getPreGroupedRowModel: () => RowModel<TGenerics>\n  getGroupedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Grouping = {\n  getDefaultColumn: <\n    TGenerics extends AnyGenerics\n  >(): GroupingColumnDef<TGenerics> => {\n    return {\n      aggregationType: 'auto',\n    }\n  },\n\n  getInitialState: (): GroupingTableState => {\n    return {\n      grouping: [],\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): GroupingOptions<TGenerics> => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', instance),\n      autoResetGrouping: true,\n      groupedColumnMode: 'reorder',\n    }\n  },\n\n  createColumn: <TGenerics extends AnyGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): GroupingColumn<TGenerics> => {\n    return {\n      aggregationType: column.aggregationType,\n      getCanGroup: () => instance.getColumnCanGroup(column.id),\n      getGroupedIndex: () => instance.getColumnGroupedIndex(column.id),\n      getIsGrouped: () => instance.getColumnIsGrouped(column.id),\n      toggleGrouping: () => instance.toggleColumnGrouping(column.id),\n      getToggleGroupingProps: userProps =>\n        instance.getToggleGroupingProps(column.id, userProps),\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): GroupingInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      _notifyGroupingReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetGrouping\n        ) {\n          instance.resetGrouping()\n        }\n      },\n      getColumnAutoAggregationFn: columnId => {\n        const firstRow = instance.getCoreRowModel().flatRows[0]\n\n        const value = firstRow?.values[columnId]\n\n        if (typeof value === 'number') {\n          return aggregationTypes.sum\n        }\n\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return aggregationTypes.extent\n        }\n\n        return aggregationTypes.count\n      },\n      getColumnAggregationFn: columnId => {\n        const column = instance.getColumn(columnId)\n        const userAggregationTypes = instance.options.aggregationTypes\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return isFunction(column.aggregationType)\n          ? column.aggregationType\n          : column.aggregationType === 'auto'\n          ? instance.getColumnAutoAggregationFn(columnId)\n          : (userAggregationTypes as Record<string, any>)?.[\n              column.aggregationType as string\n            ] ??\n            (aggregationTypes[\n              column.aggregationType as BuiltInAggregationType\n            ] as AggregationFn<TGenerics>)\n      },\n\n      setGrouping: updater =>\n        instance.options.onGroupingChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().grouping)\n        ),\n\n      toggleColumnGrouping: columnId => {\n        instance.setGrouping(old => {\n          // Find any existing grouping for this column\n          if (old?.includes(columnId)) {\n            return old.filter(d => d !== columnId)\n          }\n\n          return [...(old ?? []), columnId]\n        })\n      },\n\n      getColumnCanGroup: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableGrouping ??\n          instance.options.enableGrouping ??\n          column.defaultCanGroup ??\n          !!column.accessorFn\n        )\n      },\n\n      getColumnIsGrouped: columnId => {\n        return instance.getState().grouping?.includes(columnId)\n      },\n\n      getColumnGroupedIndex: columnId =>\n        instance.getState().grouping?.indexOf(columnId),\n\n      resetGrouping: () => {\n        instance.setGrouping(instance.initialState?.grouping ?? [])\n      },\n\n      getToggleGroupingProps: (columnId, userProps) => {\n        const column = instance.getColumn(columnId)\n\n        const canGroup = column.getCanGroup()\n\n        const initialProps: ToggleGroupingProps = {\n          title: canGroup ? 'Toggle Grouping' : undefined,\n          onClick: canGroup\n            ? (e: MouseEvent | TouchEvent) => {\n                column.toggleGrouping?.()\n              }\n            : undefined,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getRowIsGrouped: rowId => !!instance.getRow(rowId)?.groupingColumnId,\n\n      getPreGroupedRowModel: () => instance.getSortedRowModel(),\n      getGroupedRowModel: memo(\n        () => [\n          instance.getState().grouping,\n          instance.getSortedRowModel(),\n          instance.options.groupRowsFn,\n        ],\n        (grouping, rowModel, groupRowsFn) => {\n          if (!groupRowsFn || !grouping.length) {\n            return rowModel\n          }\n\n          return groupRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getGroupedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => instance._notifyExpandedReset(),\n        }\n      ),\n    }\n  },\n\n  createRow: <TGenerics extends AnyGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): GroupingRow => {\n    return {\n      getIsGrouped: () => instance.getRowIsGrouped(row.id),\n    }\n  },\n\n  createCell: <TGenerics extends AnyGenerics>(\n    cell: Cell<TGenerics>,\n    column: Column<TGenerics>,\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): GroupingCell<TGenerics> => {\n    return {\n      getIsGrouped: () =>\n        column.getIsGrouped() && column.id === row.groupingColumnId,\n      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),\n      getIsAggregated: () =>\n        !cell.getIsGrouped() &&\n        !cell.getIsPlaceholder() &&\n        row.subRows?.length > 1,\n      renderAggregatedCell: () => {\n        const template = column.aggregatedCell ?? column.cell\n\n        return template\n          ? instance.render(template, {\n              instance,\n              column,\n              row,\n              cell,\n              value: cell.value,\n            })\n          : null\n      },\n    }\n  },\n\n  orderColumns: <TGenerics extends AnyGenerics>(\n    leafColumns: Column<TGenerics>[],\n    grouping: string[],\n    groupedColumnMode?: GroupingColumnMode\n  ) => {\n    if (!grouping?.length || !groupedColumnMode) {\n      return leafColumns\n    }\n\n    const nonGroupingColumns = leafColumns.filter(\n      col => !grouping.includes(col.id)\n    )\n\n    if (groupedColumnMode === 'remove') {\n      return nonGroupingColumns\n    }\n\n    const groupingColumns = grouping\n      .map(g => leafColumns.find(col => col.id === g)!)\n      .filter(Boolean)\n\n    return [...groupingColumns, ...nonGroupingColumns]\n  },\n}\n","import { functionalUpdate, makeStateUpdater, memo } from '../utils'\n\nimport {\n  TableInstance,\n  OnChangeFn,\n  Updater,\n  Column,\n  AnyGenerics,\n  PartialGenerics,\n} from '../types'\n\nimport { Grouping } from './Grouping'\n\nexport type ColumnOrderState = string[]\n\nexport type ColumnOrderTableState = {\n  columnOrder: ColumnOrderState\n}\n\nexport type ColumnOrderOptions = {\n  onColumnOrderChange?: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderDefaultOptions = {\n  onColumnOrderChange: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderInstance<TGenerics extends AnyGenerics> = {\n  setColumnOrder: (updater: Updater<ColumnOrderState>) => void\n  resetColumnOrder: () => void\n  getOrderColumnsFn: () => (columns: Column<TGenerics>[]) => Column<TGenerics>[]\n}\n\n//\n\nexport const Ordering = {\n  getInitialState: (): ColumnOrderTableState => {\n    return {\n      columnOrder: [],\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnOrderDefaultOptions => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', instance),\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnOrderInstance<TGenerics> => {\n    return {\n      setColumnOrder: updater =>\n        instance.options.onColumnOrderChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnOrder)\n        ),\n      resetColumnOrder: () => {\n        instance.setColumnOrder(instance.initialState.columnOrder ?? [])\n      },\n      getOrderColumnsFn: memo(\n        () => [\n          instance.getState().columnOrder,\n          instance.getState().grouping,\n          instance.options.groupedColumnMode,\n        ],\n        (columnOrder, grouping, groupedColumnMode) => columns => {\n          // Sort grouped columns to the start of the column list\n          // before the headers are built\n          let orderedColumns: Column<TGenerics>[] = []\n\n          // If there is no order, return the normal columns\n          if (!columnOrder?.length) {\n            orderedColumns = columns\n          } else {\n            const columnOrderCopy = [...columnOrder]\n\n            // If there is an order, make a copy of the columns\n            const columnsCopy = [...columns]\n\n            // And make a new ordered array of the columns\n\n            // Loop over the columns and place them in order into the new array\n            while (columnsCopy.length && columnOrderCopy.length) {\n              const targetColumnId = columnOrderCopy.shift()\n              const foundIndex = columnsCopy.findIndex(\n                d => d.id === targetColumnId\n              )\n              if (foundIndex > -1) {\n                orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]!)\n              }\n            }\n\n            // If there are any columns left, add them to the end\n            orderedColumns = [...orderedColumns, ...columnsCopy]\n          }\n\n          return Grouping.orderColumns(\n            orderedColumns,\n            grouping,\n            groupedColumnMode\n          )\n        },\n        {\n          key: 'getOrderColumnsFn',\n          // debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n    }\n  },\n}\n","import {\n  OnChangeFn,\n  AnyGenerics,\n  PartialGenerics,\n  TableInstance,\n  RowModel,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo } from '../utils'\n\nexport type PaginationState = {\n  pageIndex: number\n  pageSize: number\n  pageCount: number\n}\n\nexport type PaginationTableState = {\n  pagination: PaginationState\n}\n\nexport type PaginationOptions<TGenerics extends AnyGenerics> = {\n  onPaginationChange?: OnChangeFn<PaginationState>\n  autoResetPageIndex?: boolean\n  paginateRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n}\n\nexport type PaginationDefaultOptions = {\n  onPaginationChange: OnChangeFn<PaginationState>\n  autoResetPageIndex: boolean\n}\n\nexport type PaginationInstance<TGenerics extends AnyGenerics> = {\n  _notifyPageIndexReset: () => void\n  setPagination: (updater: Updater<PaginationState>) => void\n  resetPagination: () => void\n  setPageIndex: (updater: Updater<number>) => void\n  resetPageIndex: () => void\n  setPageSize: (updater: Updater<number>) => void\n  resetPageSize: () => void\n  setPageCount: (updater: Updater<number>) => void\n  getPageOptions: () => number[]\n  getCanPreviousPage: () => boolean\n  getCanNextPage: () => boolean\n  previousPage: () => void\n  nextPage: () => void\n  getPrePaginationRowModel: () => RowModel<TGenerics>\n  getPaginationRowModel: () => RowModel<TGenerics>\n  getPageCount: () => number\n}\n\n//\n\nexport const Pagination = {\n  getInitialState: (): PaginationTableState => {\n    return {\n      pagination: {\n        pageCount: -1,\n        pageIndex: 0,\n        pageSize: 10,\n      },\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): PaginationDefaultOptions => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', instance),\n      autoResetPageIndex: true,\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): PaginationInstance<TGenerics> => {\n    let registered = false\n    return {\n      _notifyPageIndexReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetPageIndex\n        ) {\n          instance.resetPageIndex()\n        }\n      },\n      setPagination: updater => {\n        const safeUpdater: Updater<PaginationState> = old => {\n          let newState = functionalUpdate(updater, old)\n\n          return newState\n        }\n\n        return instance.options.onPaginationChange?.(\n          safeUpdater,\n          functionalUpdate(safeUpdater, instance.getState().pagination)\n        )\n      },\n      resetPagination: () => {\n        instance.setPagination(\n          instance.initialState.pagination ?? {\n            pageIndex: 0,\n            pageSize: 10,\n            pageCount: -1,\n          }\n        )\n      },\n      setPageIndex: updater => {\n        instance.setPagination(old => {\n          let pageIndex = functionalUpdate(updater, old.pageIndex)\n\n          const maxPageIndex =\n            old.pageCount && old.pageCount > 0\n              ? old.pageCount - 1\n              : Number.MAX_SAFE_INTEGER\n\n          pageIndex = Math.min(Math.max(0, pageIndex), maxPageIndex)\n\n          return {\n            ...old,\n            pageIndex,\n          }\n        })\n      },\n      resetPageIndex: () => {\n        instance.setPageIndex(0)\n      },\n      resetPageSize: () => {\n        instance.setPageSize(instance.initialState?.pagination?.pageSize ?? 10)\n      },\n      setPageSize: updater => {\n        instance.setPagination(old => {\n          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize))\n          const topRowIndex = old.pageSize * old.pageIndex!\n          const pageIndex = Math.floor(topRowIndex / pageSize)\n\n          return {\n            ...old,\n            pageIndex,\n            pageSize,\n          }\n        })\n      },\n      setPageCount: updater =>\n        instance.setPagination(old => {\n          let newPageCount = functionalUpdate(updater, old.pageCount)\n\n          if (typeof newPageCount === 'number') {\n            newPageCount = Math.max(-1, newPageCount)\n          }\n\n          return {\n            ...old,\n            pageCount: newPageCount,\n          }\n        }),\n\n      getPageOptions: memo(\n        () => [\n          instance.getState().pagination.pageSize,\n          instance.getState().pagination.pageCount,\n        ],\n        (pageSize, pageCount) => {\n          let pageOptions: number[] = []\n          if (pageCount && pageCount > 0) {\n            pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i)\n          }\n          return pageOptions\n        },\n        {\n          key: 'getPageOptions',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      getCanPreviousPage: () => instance.getState().pagination.pageIndex > 0,\n\n      getCanNextPage: () => {\n        const { pageIndex, pageSize } = instance.getState().pagination\n\n        const pageCount = instance.getPageCount()\n\n        if (pageCount === -1) {\n          return true\n        }\n\n        if (pageCount === 0) {\n          return false\n        }\n\n        return (\n          pageIndex <\n          Math.ceil(\n            instance.getPrePaginationRowModel().rows.length / pageSize\n          ) -\n            1\n        )\n      },\n\n      previousPage: () => {\n        return instance.setPageIndex(old => old - 1)\n      },\n\n      nextPage: () => {\n        return instance.setPageIndex(old => {\n          return old + 1\n        })\n      },\n\n      getPrePaginationRowModel: () => instance.getExpandedRowModel(),\n      getPaginationRowModel: memo(\n        () => [\n          instance.getState().pagination,\n          instance.getExpandedRowModel(),\n          instance.options.paginateRowsFn,\n        ],\n        (_pagination, rowModel, paginateRowsFn) => {\n          if (!paginateRowsFn || !rowModel.rows.length) {\n            return rowModel\n          }\n\n          return paginateRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getPaginationRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      getPageCount: () => {\n        const { pageCount } = instance.getState().pagination\n        if (pageCount > 0) {\n          return pageCount\n        }\n\n        return Math.ceil(\n          instance.getPrePaginationRowModel().rows.length /\n            instance.getState().pagination.pageSize\n        )\n      },\n    }\n  },\n}\n","import {\n  OnChangeFn,\n  Updater,\n  TableInstance,\n  Column,\n  AnyGenerics,\n  PartialGenerics,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater } from '../utils'\n\ntype ColumnPinningPosition = false | 'left' | 'right'\n\nexport type ColumnPinningState = {\n  left?: string[]\n  right?: string[]\n}\n\nexport type ColumnPinningTableState = {\n  columnPinning: ColumnPinningState\n}\n\nexport type ColumnPinningOptions = {\n  onColumnPinningChange?: OnChangeFn<ColumnPinningState>\n  enablePinning?: boolean\n}\n\nexport type ColumnPinningDefaultOptions = {\n  onColumnPinningChange: OnChangeFn<ColumnPinningState>\n}\n\nexport type ColumnPinningColumnDef = {\n  enablePinning?: boolean\n  defaultCanPin?: boolean\n}\n\nexport type ColumnPinningColumn = {\n  getCanPin: () => boolean\n  getPinnedIndex: () => number\n  getIsPinned: () => ColumnPinningPosition\n  pin: (position: ColumnPinningPosition) => void\n}\n\nexport type ColumnPinningInstance<TGenerics extends AnyGenerics> = {\n  setColumnPinning: (updater: Updater<ColumnPinningState>) => void\n  resetColumnPinning: () => void\n  pinColumn: (columnId: string, position: ColumnPinningPosition) => void\n  getColumnCanPin: (columnId: string) => boolean\n  getColumnIsPinned: (columnId: string) => ColumnPinningPosition\n  getColumnPinnedIndex: (columnId: string) => number\n  getIsSomeColumnsPinned: () => boolean\n}\n\n//\n\nexport const Pinning = {\n  getInitialState: (): ColumnPinningTableState => {\n    return {\n      columnPinning: {\n        left: [],\n        right: [],\n      },\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningDefaultOptions => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', instance),\n    }\n  },\n\n  createColumn: <TGenerics extends AnyGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningColumn => {\n    return {\n      getCanPin: () => instance.getColumnCanPin(column.id),\n      getPinnedIndex: () => instance.getColumnPinnedIndex(column.id),\n      getIsPinned: () => instance.getColumnIsPinned(column.id),\n      pin: position => instance.pinColumn(column.id, position),\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningInstance<TGenerics> => {\n    return {\n      setColumnPinning: updater =>\n        instance.options.onColumnPinningChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnPinning)\n        ),\n\n      resetColumnPinning: () =>\n        instance.setColumnPinning(instance.initialState?.columnPinning ?? {}),\n\n      pinColumn: (columnId, position) => {\n        const column = instance.getColumn(columnId)\n\n        const columnIds = column\n          ?.getLeafColumns()\n          .map(d => d.id)\n          .filter(Boolean) as string[]\n\n        instance.setColumnPinning(old => {\n          if (position === 'right') {\n            return {\n              left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n              right: [\n                ...(old?.right ?? []).filter(d => !columnIds?.includes(d)),\n                ...columnIds,\n              ],\n            }\n          }\n\n          if (position === 'left') {\n            return {\n              left: [\n                ...(old?.left ?? []).filter(d => !columnIds?.includes(d)),\n                ...columnIds,\n              ],\n              right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n            }\n          }\n\n          return {\n            left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n            right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n          }\n        })\n      },\n\n      getColumnCanPin: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        const leafColumns = column.getLeafColumns()\n\n        return leafColumns.some(\n          d =>\n            d.enablePinning ??\n            instance.options.enablePinning ??\n            d.defaultCanPin ??\n            !!d.accessorFn\n        )\n      },\n\n      getColumnIsPinned: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        const leafColumnIds = column.getLeafColumns().map(d => d.id)\n\n        const { left, right } = instance.getState().columnPinning\n\n        const isLeft = leafColumnIds.some(d => left?.includes(d))\n        const isRight = leafColumnIds.some(d => right?.includes(d))\n\n        return isLeft ? 'left' : isRight ? 'right' : false\n      },\n\n      getColumnPinnedIndex: columnId => {\n        const position = instance.getColumnIsPinned(columnId)\n\n        return position\n          ? instance.getState().columnPinning?.[position]?.indexOf(columnId) ??\n              -1\n          : 0\n      },\n\n      getIsSomeColumnsPinned: () => {\n        const { left, right } = instance.getState().columnPinning\n\n        return Boolean(left?.length || right?.length)\n      },\n    }\n  },\n}\n","import {\n  Getter,\n  OnChangeFn,\n  AnyGenerics,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Row,\n  RowModel,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\nexport type RowSelectionState = Record<string, boolean>\n\nexport type RowSelectionTableState = {\n  rowSelection: RowSelectionState\n}\n\nexport type RowSelectionOptions<TGenerics extends AnyGenerics> = {\n  onRowSelectionChange?: OnChangeFn<RowSelectionState>\n  autoResetRowSelection?: boolean\n  enableRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  enableMultiRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  enableSubRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  // enableGroupingRowSelection?:\n  //   | boolean\n  //   | ((\n  //       row: Row<TGenerics>\n  //     ) => boolean)\n  // isAdditiveSelectEvent?: (e: MouseEvent | TouchEvent) => boolean\n  // isInclusiveSelectEvent?: (e: MouseEvent | TouchEvent) => boolean\n  // selectRowsFn?: (\n  //   instance: TableInstance<\n  //     TData,\n  //     TValue,\n  //     TFilterFns,\n  //     TSortingFns,\n  //     TAggregationFns\n  //   >,\n  //   rowModel: RowModel<TGenerics>\n  // ) => RowModel<TGenerics>\n}\n\ntype ToggleRowSelectedProps = {\n  onChange?: (e: MouseEvent | TouchEvent) => void\n  checked?: boolean\n  title?: string\n  indeterminate?: boolean\n}\n\nexport type RowSelectionRow = {\n  getIsSelected: () => boolean\n  getIsSomeSelected: () => boolean\n  getCanSelect: () => boolean\n  getCanMultiSelect: () => boolean\n  toggleSelected: (value?: boolean) => void\n  getToggleSelectedProps: <TGetter extends Getter<ToggleRowSelectedProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleRowSelectedProps, TGetter>\n}\n\nexport type RowSelectionInstance<TGenerics extends AnyGenerics> = {\n  _notifyRowSelectionReset: () => void\n  getToggleRowSelectedProps: <TGetter extends Getter<ToggleRowSelectedProps>>(\n    rowId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleRowSelectedProps, TGetter>\n  getToggleAllRowsSelectedProps: <\n    TGetter extends Getter<ToggleRowSelectedProps>\n  >(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleRowSelectedProps, TGetter>\n  getToggleAllPageRowsSelectedProps: <\n    TGetter extends Getter<ToggleRowSelectedProps>\n  >(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleRowSelectedProps, TGetter>\n  setRowSelection: (updater: Updater<RowSelectionState>) => void\n  resetRowSelection: () => void\n  toggleRowSelected: (rowId: string, value?: boolean) => void\n  getRowCanSelect: (rowId: string) => boolean\n  getRowCanSelectSubRows: (rowId: string) => boolean\n  getRowCanMultiSelect: (rowId: string) => boolean\n  // getGroupingRowCanSelect: (rowId: string) => boolean\n  getRowIsSelected: (rowId: string) => boolean\n  getRowIsSomeSelected: (rowId: string) => boolean\n  getIsAllRowsSelected: () => boolean\n  getIsAllPageRowsSelected: () => boolean\n  getIsSomeRowsSelected: () => boolean\n  getIsSomePageRowsSelected: () => boolean\n  toggleAllRowsSelected: (value: boolean) => void\n  toggleAllPageRowsSelected: (value: boolean) => void\n  getPreSelectedRowModel: () => RowModel<TGenerics>\n  getSelectedRowModel: () => RowModel<TGenerics>\n  getFilteredSelectedRowModel: () => RowModel<TGenerics>\n  getGroupedSelectedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const RowSelection = {\n  getInitialState: (): RowSelectionTableState => {\n    return {\n      rowSelection: {},\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): RowSelectionOptions<TGenerics> => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', instance),\n      autoResetRowSelection: true,\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true,\n      // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: MouseEvent | TouchEvent) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: MouseEvent | TouchEvent) => !!e.shiftKey,\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): RowSelectionInstance<TGenerics> => {\n    let registered = false\n\n    // const pageRows = instance.getPageRows()\n\n    return {\n      _notifyRowSelectionReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetRowSelection\n        ) {\n          instance.resetRowSelection()\n        }\n      },\n      setRowSelection: updater =>\n        instance.options.onRowSelectionChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().rowSelection)\n        ),\n      resetRowSelection: () =>\n        instance.setRowSelection(instance.initialState.rowSelection ?? {}),\n      toggleAllRowsSelected: value => {\n        instance.setRowSelection(old => {\n          value =\n            typeof value !== 'undefined'\n              ? value\n              : !instance.getIsAllRowsSelected()\n\n          const rowSelection = { ...old }\n\n          const preGroupedFlatRows = instance.getPreGroupedRowModel().flatRows\n\n          // We don't use `mutateRowIsSelected` here for performance reasons.\n          // All of the rows are flat already, so it wouldn't be worth it\n          if (value) {\n            preGroupedFlatRows.forEach(row => {\n              rowSelection[row.id] = true\n            })\n          } else {\n            preGroupedFlatRows.forEach(row => {\n              delete rowSelection[row.id]\n            })\n          }\n\n          return rowSelection\n        })\n      },\n      toggleAllPageRowsSelected: value =>\n        instance.setRowSelection(old => {\n          const selectAll =\n            typeof value !== 'undefined'\n              ? value\n              : !instance.getIsAllPageRowsSelected()\n\n          const rowSelection: RowSelectionState = { ...old }\n\n          instance.getRowModel().rows.forEach(row => {\n            mutateRowIsSelected(rowSelection, row.id, value, instance)\n          })\n\n          return rowSelection\n        }),\n      toggleRowSelected: (rowId, value) => {\n        const row = instance.getRow(rowId)\n        const isSelected = row.getIsSelected()\n\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !isSelected\n\n          if (isSelected === value) {\n            return old\n          }\n\n          const selectedRowIds = { ...old }\n\n          mutateRowIsSelected(selectedRowIds, rowId, value, instance)\n\n          return selectedRowIds\n        })\n      },\n      // addRowSelectionRange: rowId => {\n      //   const {\n      //     rows,\n      //     rowsById,\n      //     options: { selectGroupingRows, selectSubRows },\n      //   } = instance\n\n      //   const findSelectedRow = (rows: Row[]) => {\n      //     let found\n      //     rows.find(d => {\n      //       if (d.getIsSelected()) {\n      //         found = d\n      //         return true\n      //       }\n      //       const subFound = findSelectedRow(d.subRows || [])\n      //       if (subFound) {\n      //         found = subFound\n      //         return true\n      //       }\n      //       return false\n      //     })\n      //     return found\n      //   }\n\n      //   const firstRow = findSelectedRow(rows) || rows[0]\n      //   const lastRow = rowsById[rowId]\n\n      //   let include = false\n      //   const selectedRowIds = {}\n\n      //   const addRow = (row: Row) => {\n      //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n      //       rowsById,\n      //       selectGroupingRows: selectGroupingRows!,\n      //       selectSubRows: selectSubRows!,\n      //     })\n      //   }\n\n      //   instance.rows.forEach(row => {\n      //     const isFirstRow = row.id === firstRow.id\n      //     const isLastRow = row.id === lastRow.id\n\n      //     if (isFirstRow || isLastRow) {\n      //       if (!include) {\n      //         include = true\n      //       } else if (include) {\n      //         addRow(row)\n      //         include = false\n      //       }\n      //     }\n\n      //     if (include) {\n      //       addRow(row)\n      //     }\n      //   })\n\n      //   instance.setRowSelection(selectedRowIds)\n      // },\n      getPreSelectedRowModel: () => instance.getCoreRowModel(),\n      getSelectedRowModel: memo(\n        () => [instance.getState().rowSelection, instance.getCoreRowModel()],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => instance._notifyExpandedReset(),\n        }\n      ),\n\n      getFilteredSelectedRowModel: memo(\n        () => [\n          instance.getState().rowSelection,\n          instance.getGlobalFilteredRowModel(),\n        ],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getFilteredSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => instance._notifyExpandedReset(),\n        }\n      ),\n\n      getGroupedSelectedRowModel: memo(\n        () => [instance.getState().rowSelection, instance.getGroupedRowModel()],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getGroupedSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => instance._notifyExpandedReset(),\n        }\n      ),\n\n      ///\n\n      getRowIsSelected: rowId => {\n        const { rowSelection } = instance.getState()\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        return isRowSelected(row, rowSelection, instance) === true\n      },\n\n      getRowIsSomeSelected: rowId => {\n        const { rowSelection } = instance.getState()\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        return isRowSelected(row, rowSelection, instance) === 'some'\n      },\n\n      getRowCanSelect: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        if (typeof instance.options.enableRowSelection === 'function') {\n          return instance.options.enableRowSelection(row)\n        }\n\n        return instance.options.enableRowSelection ?? true\n      },\n\n      getRowCanSelectSubRows: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        if (typeof instance.options.enableSubRowSelection === 'function') {\n          return instance.options.enableSubRowSelection(row)\n        }\n\n        return instance.options.enableSubRowSelection ?? true\n      },\n\n      getRowCanMultiSelect: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        if (typeof instance.options.enableMultiRowSelection === 'function') {\n          return instance.options.enableMultiRowSelection(row)\n        }\n\n        return instance.options.enableMultiRowSelection ?? true\n      },\n\n      // getGroupingRowCanSelect: rowId => {\n      //   const row = instance.getRow(rowId)\n\n      //   if (!row) {\n      //     throw new Error()\n      //   }\n\n      //   if (typeof instance.options.enableGroupingRowSelection === 'function') {\n      //     return instance.options.enableGroupingRowSelection(row)\n      //   }\n\n      //   return instance.options.enableGroupingRowSelection ?? false\n      // },\n\n      getIsAllRowsSelected: () => {\n        const preFilteredFlatRows =\n          instance.getPreGlobalFilteredRowModel().flatRows\n        const { rowSelection } = instance.getState()\n\n        let isAllRowsSelected = Boolean(\n          preFilteredFlatRows.length && Object.keys(rowSelection).length\n        )\n\n        if (isAllRowsSelected) {\n          if (preFilteredFlatRows.some(row => !rowSelection[row.id])) {\n            isAllRowsSelected = false\n          }\n        }\n\n        return isAllRowsSelected\n      },\n\n      getIsAllPageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows\n        const { rowSelection } = instance.getState()\n\n        let isAllPageRowsSelected = !!paginationFlatRows.length\n\n        if (\n          isAllPageRowsSelected &&\n          paginationFlatRows.some(row => !rowSelection[row.id])\n        ) {\n          isAllPageRowsSelected = false\n        }\n\n        return isAllPageRowsSelected\n      },\n\n      getIsSomeRowsSelected: () => {\n        return (\n          !instance.getIsAllRowsSelected() &&\n          !!Object.keys(instance.getState().rowSelection ?? {}).length\n        )\n      },\n\n      getIsSomePageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows\n        return instance.getIsAllPageRowsSelected()\n          ? false\n          : !!paginationFlatRows?.length\n      },\n\n      getToggleRowSelectedProps: (rowId, userProps) => {\n        const row = instance.getRow(rowId)\n\n        const isSelected = row.getIsSelected()\n        const isSomeSelected = row.getIsSomeSelected()\n        const canSelect = row.getCanSelect()\n\n        const initialProps: ToggleRowSelectedProps = {\n          onChange: canSelect\n            ? (e: MouseEvent | TouchEvent) => {\n                row.toggleSelected((e.target as HTMLInputElement).checked)\n              }\n            : undefined,\n          checked: isSelected,\n          title: 'Toggle Row Selected',\n          indeterminate: isSomeSelected,\n          // onChange: forInput\n          //   ? (e: Event) => e.stopPropagation()\n          //   : (e: Event) => {\n          //       if (instance.options.isAdditiveSelectEvent(e)) {\n          //         row.toggleSelected()\n          //       } else if (instance.options.isInclusiveSelectEvent(e)) {\n          //         instance.addRowSelectionRange(row.id)\n          //       } else {\n          //         instance.setRowSelection({})\n          //         row.toggleSelected()\n          //       }\n\n          //       if (props.onClick) props.onClick(e)\n          //     },\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getToggleAllRowsSelectedProps: userProps => {\n        const isSomeRowsSelected = instance.getIsSomeRowsSelected()\n        const isAllRowsSelected = instance.getIsAllRowsSelected()\n\n        const initialProps: ToggleRowSelectedProps = {\n          onChange: (e: MouseEvent | TouchEvent) => {\n            instance.toggleAllRowsSelected(\n              (e.target as HTMLInputElement).checked\n            )\n          },\n          checked: isAllRowsSelected,\n          title: 'Toggle All Rows Selected',\n          indeterminate: isSomeRowsSelected,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getToggleAllPageRowsSelectedProps: userProps => {\n        const isSomePageRowsSelected = instance.getIsSomePageRowsSelected()\n        const isAllPageRowsSelected = instance.getIsAllPageRowsSelected()\n\n        const initialProps: ToggleRowSelectedProps = {\n          onChange: (e: MouseEvent | TouchEvent) => {\n            instance.toggleAllPageRowsSelected(\n              (e.target as HTMLInputElement).checked\n            )\n          },\n          checked: isAllPageRowsSelected,\n          title: 'Toggle All Current Page Rows Selected',\n          indeterminate: isSomePageRowsSelected,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n    }\n  },\n\n  createRow: <TGenerics extends AnyGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): RowSelectionRow => {\n    return {\n      getIsSelected: () => instance.getRowIsSelected(row.id),\n      getIsSomeSelected: () => instance.getRowIsSomeSelected(row.id),\n      toggleSelected: value => instance.toggleRowSelected(row.id, value),\n      getToggleSelectedProps: userProps =>\n        instance.getToggleRowSelectedProps(row.id, userProps),\n      getCanMultiSelect: () => instance.getRowCanMultiSelect(row.id),\n      getCanSelect: () => instance.getRowCanSelect(row.id),\n    }\n  },\n}\n\nconst mutateRowIsSelected = <TGenerics extends AnyGenerics>(\n  selectedRowIds: Record<string, boolean>,\n  id: string,\n  value: boolean,\n  instance: TableInstance<TGenerics>\n) => {\n  const row = instance.getRow(id)\n\n  const isGrouped = row.getIsGrouped()\n\n  // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && instance.options.enableGroupingRowSelection)\n  // ) {\n  if (value) {\n    selectedRowIds[id] = true\n  } else {\n    delete selectedRowIds[id]\n  }\n  // }\n\n  if (row.subRows?.length && instance.getRowCanSelectSubRows(row.id)) {\n    row.subRows.forEach(row =>\n      mutateRowIsSelected(selectedRowIds, row.id, value, instance)\n    )\n  }\n}\n\nexport function selectRowsFn<TGenerics extends AnyGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const rowSelection = instance.getState().rowSelection\n\n  const newSelectedFlatRows: Row<TGenerics>[] = []\n  const newSelectedRowsById: Record<string, Row<TGenerics>> = {}\n\n  // Filters top level and nested rows\n  const recurseRows = (rows: Row<TGenerics>[], depth = 0) => {\n    return rows\n      .map(row => {\n        const isSelected = isRowSelected(row, rowSelection, instance) === true\n\n        if (isSelected) {\n          newSelectedFlatRows.push(row)\n          newSelectedRowsById[row.id] = row\n        }\n\n        if (row.subRows?.length) {\n          row = {\n            ...row,\n            subRows: recurseRows(row.subRows, depth + 1),\n          }\n        }\n\n        if (isSelected) {\n          return row\n        }\n      })\n      .filter(Boolean) as Row<TGenerics>[]\n  }\n\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById,\n  }\n}\n\nexport function isRowSelected<TGenerics extends AnyGenerics>(\n  row: Row<TGenerics>,\n  selection: Record<string, boolean>,\n  instance: TableInstance<TGenerics>\n): boolean | 'some' {\n  if (selection[row.id]) {\n    return true\n  }\n\n  if (row.subRows && row.subRows.length) {\n    let allChildrenSelected = true\n    let someSelected = false\n\n    row.subRows.forEach(subRow => {\n      // Bail out early if we know both of these\n      if (someSelected && !allChildrenSelected) {\n        return\n      }\n\n      if (isRowSelected(subRow, selection, instance)) {\n        someSelected = true\n      } else {\n        allChildrenSelected = false\n      }\n    })\n\n    return allChildrenSelected ? true : someSelected ? 'some' : false\n  }\n\n  return false\n}\n","import { PartialGenerics, AnyGenerics, Row } from './types'\n\nexport const reSplitAlphaNumeric = /([0-9]+)/gm\n\nexport const sortTypes = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic,\n}\n\nexport type BuiltInSortType = keyof typeof sortTypes\n\nfunction alphanumeric<TGenerics extends AnyGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareAlphanumeric(\n    toString(rowA.values[columnId]).toLowerCase(),\n    toString(rowB.values[columnId]).toLowerCase()\n  )\n}\n\nfunction alphanumericCaseSensitive<TGenerics extends AnyGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareAlphanumeric(\n    toString(rowA.values[columnId]),\n    toString(rowB.values[columnId])\n  )\n}\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr: string, bStr: string) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean)\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean)\n\n  // While\n  while (a.length && b.length) {\n    const aa = a.shift()!\n    const bb = b.shift()!\n\n    const an = parseInt(aa, 10)\n    const bn = parseInt(bb, 10)\n\n    const combo = [an, bn].sort()\n\n    // Both are string\n    if (isNaN(combo[0]!)) {\n      if (aa > bb) {\n        return 1\n      }\n      if (bb > aa) {\n        return -1\n      }\n      continue\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1]!)) {\n      return isNaN(an) ? -1 : 1\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1\n    }\n    if (bn > an) {\n      return -1\n    }\n  }\n\n  return a.length - b.length\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nfunction text<TGenerics extends AnyGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    toString(rowA.values[columnId]).toLowerCase(),\n    toString(rowB.values[columnId]).toLowerCase()\n  )\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nfunction textCaseSensitive<TGenerics extends AnyGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    toString(rowA.values[columnId]),\n    toString(rowB.values[columnId])\n  )\n}\n\nfunction datetime<TGenerics extends AnyGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    (rowA.values[columnId] as Date).getTime(),\n    (rowB.values[columnId] as Date).getTime()\n  )\n}\n\nfunction basic<TGenerics extends AnyGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(rowA.values[columnId], rowB.values[columnId])\n}\n\n// Utils\n\nfunction compareBasic(a: any, b: any) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\nfunction toString(a: any) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return ''\n    }\n    return String(a)\n  }\n  if (typeof a === 'string') {\n    return a\n  }\n  return ''\n}\n","import { MouseEvent, TouchEvent } from 'react'\nimport { RowModel } from '..'\nimport { BuiltInSortType, reSplitAlphaNumeric, sortTypes } from '../sortTypes'\n\nimport {\n  Column,\n  Getter,\n  Header,\n  OnChangeFn,\n  AnyGenerics,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Row,\n  Updater,\n} from '../types'\n\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  Overwrite,\n  propGetter,\n} from '../utils'\n\nexport type SortDirection = 'asc' | 'desc'\n\nexport type ColumnSort = {\n  id: string\n  desc: boolean\n}\n\nexport type SortingState = ColumnSort[]\n\nexport type SortingFn<TGenerics extends AnyGenerics> = {\n  (rowA: Row<TGenerics>, rowB: Row<TGenerics>, columnId: string): number\n}\n\nexport type CustomSortingTypes<TGenerics extends AnyGenerics> = Record<\n  string,\n  SortingFn<TGenerics>\n>\n\nexport type SortingTableState = {\n  sorting: SortingState\n}\n\nexport type SortType<TGenerics extends AnyGenerics> =\n  | 'auto'\n  | BuiltInSortType\n  | keyof TGenerics['SortingFns']\n  | SortingFn<TGenerics>\n\nexport type SortingColumnDef<TGenerics extends AnyGenerics> = {\n  sortType?: SortType<Overwrite<TGenerics, { Value: any }>>\n  sortDescFirst?: boolean\n  enableSorting?: boolean\n  enableMultiSort?: boolean\n  defaultCanSort?: boolean\n  invertSorting?: boolean\n  sortUndefined?: false | -1 | 1\n}\n\nexport type SortingColumn<TGenerics extends AnyGenerics> = {\n  sortType: SortType<Overwrite<TGenerics, { Value: any }>>\n  getCanSort: () => boolean\n  getCanMultiSort: () => boolean\n  getSortIndex: () => number\n  getIsSorted: () => false | SortDirection\n  resetSorting: () => void\n  toggleSorting: (desc?: boolean, isMulti?: boolean) => void\n  getToggleSortingProps: <TGetter extends Getter<ToggleSortingProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleSortingProps, TGetter>\n}\n\nexport type SortingOptions<TGenerics extends AnyGenerics> = {\n  sortTypes?: TGenerics['SortingFns']\n  onSortingChange?: OnChangeFn<SortingState>\n  autoResetSorting?: boolean\n  enableSorting?: boolean\n  enableSortingRemoval?: boolean\n  enableMultiRemove?: boolean\n  enableMultiSort?: boolean\n  sortDescFirst?: boolean\n  sortRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n  maxMultiSortColCount?: number\n  isMultiSortEvent?: (e: MouseEvent | TouchEvent) => boolean\n}\n\nexport type ToggleSortingProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type SortingInstance<TGenerics extends AnyGenerics> = {\n  _notifySortingReset: () => void\n  getColumnAutoSortingFn: (columnId: string) => SortingFn<TGenerics> | undefined\n  getColumnAutoSortDir: (columnId: string) => SortDirection\n\n  getColumnSortingFn: (columnId: string) => SortingFn<TGenerics> | undefined\n\n  setSorting: (updater: Updater<SortingState>) => void\n  toggleColumnSorting: (\n    columnId: string,\n    desc?: boolean,\n    multi?: boolean\n  ) => void\n  resetSorting: (columnId?: string) => void\n  getColumnCanSort: (columnId: string) => boolean\n  getColumnCanMultiSort: (columnId: string) => boolean\n  getColumnIsSorted: (columnId: string) => false | 'asc' | 'desc'\n  getColumnSortIndex: (columnId: string) => number\n  getToggleSortingProps: <TGetter extends Getter<ToggleSortingProps>>(\n    columnId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleSortingProps, TGetter>\n  getPreSortedRowModel: () => RowModel<TGenerics>\n  getSortedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Sorting = {\n  getDefaultColumn: <\n    TGenerics extends AnyGenerics\n  >(): SortingColumnDef<TGenerics> => {\n    return {\n      sortType: 'auto',\n    }\n  },\n\n  getInitialState: (): SortingTableState => {\n    return {\n      sorting: [],\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): SortingOptions<TGenerics> => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', instance),\n      autoResetSorting: true,\n      isMultiSortEvent: (e: MouseEvent | TouchEvent) => {\n        return e.shiftKey\n      },\n    }\n  },\n\n  createColumn: <TGenerics extends AnyGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): SortingColumn<TGenerics> => {\n    return {\n      sortType: column.sortType,\n      getCanSort: () => instance.getColumnCanSort(column.id),\n      getCanMultiSort: () => instance.getColumnCanMultiSort(column.id),\n      getSortIndex: () => instance.getColumnSortIndex(column.id),\n      getIsSorted: () => instance.getColumnIsSorted(column.id),\n      resetSorting: () => instance.resetSorting(column.id),\n      toggleSorting: (desc, isMulti) =>\n        instance.toggleColumnSorting(column.id, desc, isMulti),\n      getToggleSortingProps: userProps =>\n        instance.getToggleSortingProps(column.id, userProps),\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): SortingInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      _notifySortingReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetSorting\n        ) {\n          instance.resetSorting()\n        }\n      },\n      getColumnAutoSortingFn: columnId => {\n        const firstRows = instance\n          .getGlobalFilteredRowModel()\n          .flatRows.slice(100)\n\n        let isString = false\n\n        for (const row of firstRows) {\n          const value = row?.values[columnId]\n\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            return sortTypes.datetime\n          }\n\n          if (typeof value === 'string') {\n            isString = true\n\n            if (value.split(reSplitAlphaNumeric).length > 1) {\n              return sortTypes.alphanumeric\n            }\n          }\n        }\n\n        if (isString) {\n          return sortTypes.text\n        }\n\n        return sortTypes.basic\n      },\n      getColumnAutoSortDir: columnId => {\n        const firstRow = instance.getGlobalFilteredRowModel().flatRows[0]\n\n        const value = firstRow?.values[columnId]\n\n        if (typeof value === 'string') {\n          return 'asc'\n        }\n\n        return 'desc'\n      },\n      getColumnSortingFn: columnId => {\n        const column = instance.getColumn(columnId)\n        const userSortTypes = instance.options.sortTypes\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return isFunction(column.sortType)\n          ? column.sortType\n          : column.sortType === 'auto'\n          ? instance.getColumnAutoSortingFn(columnId)\n          : (userSortTypes as Record<string, any>)?.[\n              column.sortType as string\n            ] ??\n            (sortTypes[\n              column.sortType as BuiltInSortType\n            ] as SortingFn<TGenerics>)\n      },\n\n      setSorting: updater =>\n        instance.options.onSortingChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().sorting)\n        ),\n\n      toggleColumnSorting: (columnId, desc, multi) => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        // if (column.columns.length) {\n        //   column.columns.forEach((c, i) => {\n        //     if (c.id) {\n        //       instance.toggleColumnSorting(c.id, undefined, multi || !!i)\n        //     }\n        //   })\n        //   return\n        // }\n\n        instance.setSorting(old => {\n          // Find any existing sorting for this column\n          const existingSorting = old?.find(d => d.id === columnId)\n          const existingIndex = old?.findIndex(d => d.id === columnId)\n          const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n          let newSorting: SortingState = []\n\n          // What should we do with this sort action?\n          let sortAction\n\n          if (column.getCanMultiSort() && multi) {\n            if (existingSorting) {\n              sortAction = 'toggle'\n            } else {\n              sortAction = 'add'\n            }\n          } else {\n            // Normal mode\n            if (old?.length && existingIndex !== old.length - 1) {\n              sortAction = 'replace'\n            } else if (existingSorting) {\n              sortAction = 'toggle'\n            } else {\n              sortAction = 'replace'\n            }\n          }\n\n          const sortDescFirst =\n            column.sortDescFirst ??\n            instance.options.sortDescFirst ??\n            instance.getColumnAutoSortDir(columnId) === 'desc'\n\n          // Handle toggle states that will remove the sorting\n          if (\n            sortAction === 'toggle' && // Must be toggling\n            (instance.options.enableSortingRemoval ?? true) && // If enableSortRemove, enable in general\n            !hasDescDefined && // Must not be setting desc\n            (multi ? instance.options.enableMultiRemove ?? true : true) && // If multi, don't allow if enableMultiRemove\n            (existingSorting?.desc // Finally, detect if it should indeed be removed\n              ? !sortDescFirst\n              : sortDescFirst)\n          ) {\n            sortAction = 'remove'\n          }\n\n          if (sortAction === 'replace') {\n            newSorting = [\n              {\n                id: columnId,\n                desc: hasDescDefined ? desc! : !!sortDescFirst,\n              },\n            ]\n          } else if (sortAction === 'add' && old?.length) {\n            newSorting = [\n              ...old,\n              {\n                id: columnId,\n                desc: hasDescDefined ? desc! : !!sortDescFirst,\n              },\n            ]\n            // Take latest n columns\n            newSorting.splice(\n              0,\n              newSorting.length -\n                (instance.options.maxMultiSortColCount ??\n                  Number.MAX_SAFE_INTEGER)\n            )\n          } else if (sortAction === 'toggle' && old?.length) {\n            // This flips (or sets) the\n            newSorting = old.map(d => {\n              if (d.id === columnId) {\n                return {\n                  ...d,\n                  desc: hasDescDefined ? desc! : !existingSorting?.desc,\n                }\n              }\n              return d\n            })\n          } else if (sortAction === 'remove' && old?.length) {\n            newSorting = old.filter(d => d.id !== columnId)\n          }\n\n          return newSorting\n        })\n      },\n\n      getColumnCanSort: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableSorting ??\n          instance.options.enableSorting ??\n          column.defaultCanSort ??\n          !!column.accessorFn\n          // (!!column.accessorFn ||\n          //   column.columns?.some(c => c.id && instance.getColumnCanSort(c.id))) ??\n          // false\n        )\n      },\n\n      getColumnCanMultiSort: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableMultiSort ??\n          instance.options.enableMultiSort ??\n          !!column.accessorFn\n        )\n      },\n\n      getColumnIsSorted: columnId => {\n        const columnSort = instance\n          .getState()\n          .sorting?.find(d => d.id === columnId)\n\n        return !columnSort ? false : columnSort.desc ? 'desc' : 'asc'\n      },\n\n      getColumnSortIndex: columnId =>\n        instance.getState().sorting?.findIndex(d => d.id === columnId) ?? -1,\n\n      resetSorting: (columnId?: string) => {\n        if (columnId) {\n          instance.setSorting(old =>\n            old?.length ? old.filter(d => d.id !== columnId) : []\n          )\n        } else {\n          instance.setSorting(instance.initialState?.sorting ?? [])\n        }\n      },\n\n      getToggleSortingProps: (columnId, userProps) => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        const canSort = column.getCanSort()\n\n        const initialProps: ToggleSortingProps = {\n          title: canSort ? 'Toggle Sorting' : undefined,\n          onClick: canSort\n            ? (e: MouseEvent | TouchEvent) => {\n                e.persist()\n                column.toggleSorting?.(\n                  undefined,\n                  column.getCanMultiSort()\n                    ? instance.options.isMultiSortEvent?.(e)\n                    : false\n                )\n              }\n            : undefined,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getPreSortedRowModel: () => instance.getGlobalFilteredRowModel(),\n      getSortedRowModel: memo(\n        () => [\n          instance.getState().sorting,\n          instance.getGlobalFilteredRowModel(),\n          instance.options.sortRowsFn,\n        ],\n        (sorting, rowModel, sortingFn) => {\n          if (!sortingFn || !sorting?.length) {\n            return rowModel\n          }\n\n          return sortingFn(instance, rowModel)\n        },\n        {\n          key: 'getSortedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => {\n            instance._notifyGroupingReset()\n          },\n        }\n      ),\n    }\n  },\n}\n","import {\n  Cell,\n  Column,\n  Getter,\n  OnChangeFn,\n  AnyGenerics,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\nexport type VisibilityOptions = {\n  onColumnVisibilityChange?: OnChangeFn<VisibilityState>\n  enableHiding?: boolean\n}\n\nexport type VisibilityDefaultOptions = {\n  onColumnVisibilityChange: OnChangeFn<VisibilityState>\n}\n\nexport type VisibilityState = Record<string, boolean>\n\nexport type VisibilityTableState = {\n  columnVisibility: VisibilityState\n}\n\nexport type VisibilityInstance<TGenerics extends AnyGenerics> = {\n  getVisibleFlatColumns: () => Column<TGenerics>[]\n  getVisibleLeafColumns: () => Column<TGenerics>[]\n  setColumnVisibility: (updater: Updater<VisibilityState>) => void\n  toggleColumnVisibility: (columnId: string, value?: boolean) => void\n  toggleAllColumnsVisible: (value?: boolean) => void\n  getColumnIsVisible: (columId: string) => boolean\n  getColumnCanHide: (columnId: string) => boolean\n  getIsAllColumnsVisible: () => boolean\n  getIsSomeColumnsVisible: () => boolean\n  getToggleAllColumnsVisibilityProps: <\n    TGetter extends Getter<ToggleAllColumnsVisibilityProps>\n  >(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleAllColumnsVisibilityProps, TGetter>\n}\n\ntype ToggleVisibilityProps = {}\ntype ToggleAllColumnsVisibilityProps = {}\n\nexport type VisibilityColumnDef = {\n  enableHiding?: boolean\n  defaultCanHide?: boolean\n  defaultIsVisible?: boolean\n}\n\nexport type VisibilityRow<TGenerics extends AnyGenerics> = {\n  getVisibleCells: () => Cell<TGenerics>[]\n}\n\nexport type VisibilityColumn = {\n  getCanHide: () => boolean\n  getIsVisible: () => boolean\n  toggleVisibility: (value?: boolean) => void\n  getToggleVisibilityProps: <TGetter extends Getter<ToggleVisibilityProps>>(\n    userProps?: TGetter\n  ) => PropGetterValue<ToggleVisibilityProps, TGetter>\n}\n\n//\n\nexport const Visibility = {\n  getInitialState: (): VisibilityTableState => {\n    return {\n      columnVisibility: {},\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): VisibilityDefaultOptions => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', instance),\n    }\n  },\n\n  getDefaultColumn: () => {\n    return {\n      defaultIsVisible: true,\n    }\n  },\n\n  createColumn: <TGenerics extends AnyGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): VisibilityColumn => {\n    return {\n      getCanHide: () => instance.getColumnCanHide(column.id),\n      getIsVisible: () => instance.getColumnIsVisible(column.id),\n      toggleVisibility: value =>\n        instance.toggleColumnVisibility(column.id, value),\n      getToggleVisibilityProps: userProps => {\n        const props: ToggleVisibilityProps = {\n          type: 'checkbox',\n          checked: column.getIsVisible?.(),\n          title: 'Toggle Column Visibility',\n          onChange: (e: MouseEvent | TouchEvent) => {\n            column.toggleVisibility?.((e.target as HTMLInputElement).checked)\n          },\n        }\n\n        return propGetter(props, userProps)\n      },\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): VisibilityInstance<TGenerics> => {\n    return {\n      getVisibleFlatColumns: memo(\n        () => [\n          instance.getAllFlatColumns(),\n          instance\n            .getAllFlatColumns()\n            .filter(d => d.getIsVisible?.())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        allFlatColumns => {\n          return allFlatColumns.filter(d => d.getIsVisible?.())\n        },\n        {\n          key: 'getVisibleFlatColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      getVisibleLeafColumns: memo(\n        () => [\n          instance.getAllLeafColumns(),\n          instance\n            .getAllLeafColumns()\n            .filter(d => d.getIsVisible?.())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        allFlatColumns => {\n          return allFlatColumns.filter(d => d.getIsVisible?.())\n        },\n        {\n          key: 'getVisibleLeafColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      setColumnVisibility: updater =>\n        instance.options.onColumnVisibilityChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnVisibility)\n        ),\n\n      toggleColumnVisibility: (columnId, value) => {\n        if (!columnId) return\n\n        if (instance.getColumnCanHide(columnId)) {\n          instance.setColumnVisibility(old => ({\n            ...old,\n            [columnId]: value ?? !instance.getColumnIsVisible(columnId),\n          }))\n        }\n      },\n\n      toggleAllColumnsVisible: value => {\n        value = value ?? !instance.getIsAllColumnsVisible()\n\n        instance.setColumnVisibility(\n          instance.getAllLeafColumns().reduce(\n            (obj, column) => ({\n              ...obj,\n              [column.id]: !value ? !column.getCanHide?.() : value,\n            }),\n            {}\n          )\n        )\n      },\n\n      getColumnIsVisible: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          instance.getState().columnVisibility?.[columnId] ??\n          column.defaultIsVisible ??\n          true\n        )\n      },\n\n      getColumnCanHide: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          instance.options.enableHiding ??\n          column.enableHiding ??\n          column.defaultCanHide ??\n          true\n        )\n      },\n\n      getIsAllColumnsVisible: () =>\n        !instance.getAllLeafColumns().some(column => !column.getIsVisible?.()),\n\n      getIsSomeColumnsVisible: () =>\n        instance.getAllLeafColumns().some(column => column.getIsVisible?.()),\n\n      getToggleAllColumnsVisibilityProps: userProps => {\n        const props: ToggleAllColumnsVisibilityProps = {\n          onChange: (e: MouseEvent) => {\n            instance.toggleAllColumnsVisible(\n              (e.target as HTMLInputElement)?.checked\n            )\n          },\n          type: 'checkbox',\n          title: 'Toggle visibility for all columns',\n          checked: instance.getIsAllColumnsVisible(),\n          indeterminate:\n            !instance.getIsAllColumnsVisible() &&\n            instance.getIsSomeColumnsVisible()\n              ? 'indeterminate'\n              : undefined,\n        }\n\n        return propGetter(props, userProps)\n      },\n    }\n  },\n}\n","import {\n  Cell,\n  Column,\n  CoreHeader,\n  FooterGroupProps,\n  FooterProps,\n  Getter,\n  Header,\n  HeaderGroup,\n  HeaderGroupProps,\n  HeaderProps,\n  AnyGenerics,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Row,\n} from '../types'\nimport { propGetter, memo } from '../utils'\nimport { ColumnSizing } from './ColumnSizing'\n\nexport type HeadersRow<TGenerics extends AnyGenerics> = {\n  _getAllVisibleCells: () => Cell<TGenerics>[]\n  getVisibleCells: () => Cell<TGenerics>[]\n  getLeftVisibleCells: () => Cell<TGenerics>[]\n  getCenterVisibleCells: () => Cell<TGenerics>[]\n  getRightVisibleCells: () => Cell<TGenerics>[]\n}\n\nexport type HeadersInstance<TGenerics extends AnyGenerics> = {\n  createHeader: (\n    column: Column<TGenerics>,\n    options: {\n      id?: string\n      isPlaceholder?: boolean\n      placeholderId?: string\n      depth: number\n    }\n  ) => Header<TGenerics>\n  getHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getLeftHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getCenterHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getRightHeaderGroups: () => HeaderGroup<TGenerics>[]\n\n  getFooterGroups: () => HeaderGroup<TGenerics>[]\n  getLeftFooterGroups: () => HeaderGroup<TGenerics>[]\n  getCenterFooterGroups: () => HeaderGroup<TGenerics>[]\n  getRightFooterGroups: () => HeaderGroup<TGenerics>[]\n\n  getFlatHeaders: () => Header<TGenerics>[]\n  getLeftFlatHeaders: () => Header<TGenerics>[]\n  getCenterFlatHeaders: () => Header<TGenerics>[]\n  getRightFlatHeaders: () => Header<TGenerics>[]\n\n  getLeafHeaders: () => Header<TGenerics>[]\n  getLeftLeafHeaders: () => Header<TGenerics>[]\n  getCenterLeafHeaders: () => Header<TGenerics>[]\n  getRightLeafHeaders: () => Header<TGenerics>[]\n\n  getHeader: (id: string) => Header<TGenerics>\n\n  getHeaderGroupProps: <TGetter extends Getter<HeaderGroupProps>>(\n    id: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<HeaderGroupProps, TGetter>\n  getFooterGroupProps: <TGetter extends Getter<FooterGroupProps>>(\n    id: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<FooterGroupProps, TGetter>\n  getHeaderProps: <TGetter extends Getter<HeaderProps>>(\n    headerId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<HeaderProps, TGetter>\n  getFooterProps: <TGetter extends Getter<FooterProps>>(\n    headerId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<FooterProps, TGetter>\n  getTotalWidth: () => number\n}\n\n//\n\nexport const Headers = {\n  createRow: <TGenerics extends AnyGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): HeadersRow<TGenerics> => {\n    return {\n      _getAllVisibleCells: memo(\n        () => [\n          row\n            .getAllCells()\n            .filter(cell => cell.column.getIsVisible())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        _ => {\n          return row.getAllCells().filter(cell => cell.column.getIsVisible())\n        },\n        {\n          key: 'row._getAllVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getVisibleCells: memo(\n        () => [\n          row.getLeftVisibleCells(),\n          row.getCenterVisibleCells(),\n          row.getRightVisibleCells(),\n        ],\n        (left, center, right) => [...left, ...center, ...right],\n        {\n          key: 'row.getVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getCenterVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allCells, left, right) => {\n          const leftAndRight = [...(left ?? []), ...(right ?? [])]\n\n          return allCells.filter(d => !leftAndRight.includes(d.columnId))\n        },\n        {\n          key: 'row.getCenterVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getLeftVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.left,\n          ,\n        ],\n        (allCells, left) => {\n          const cells = (left ?? [])\n            .map(columnId => allCells.find(cell => cell.columnId === columnId)!)\n            .filter(Boolean)\n\n          return cells\n        },\n        {\n          key: 'row.getLeftVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getRightVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.right,\n        ],\n        (allCells, right) => {\n          const cells = (right ?? [])\n            .map(columnId => allCells.find(cell => cell.columnId === columnId)!)\n            .filter(Boolean)\n\n          return cells\n        },\n        {\n          key: 'row.getRightVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n    }\n  },\n\n  getInstance: <TGenerics extends AnyGenerics>(\n    instance: TableInstance<TGenerics>\n  ): HeadersInstance<TGenerics> => {\n    return {\n      createHeader: (\n        column: Column<TGenerics>,\n        options: {\n          id?: string\n          isPlaceholder?: boolean\n          placeholderId?: string\n          depth: number\n        }\n      ) => {\n        const id = options.id ?? column.id\n\n        let header: CoreHeader<TGenerics> = {\n          id,\n          column,\n          isPlaceholder: options.isPlaceholder,\n          placeholderId: options.placeholderId,\n          depth: options.depth,\n          subHeaders: [],\n          colSpan: 0,\n          rowSpan: 0,\n          getWidth: () => {\n            let sum = 0\n\n            const recurse = (header: CoreHeader<TGenerics>) => {\n              if (header.subHeaders.length) {\n                header.subHeaders.forEach(recurse)\n              } else {\n                sum += header.column.getWidth() ?? 0\n              }\n            }\n\n            recurse(header)\n\n            return sum\n          },\n          getLeafHeaders: (): Header<TGenerics>[] => {\n            const leafHeaders: CoreHeader<TGenerics>[] = []\n\n            const recurseHeader = (h: CoreHeader<TGenerics>) => {\n              if (h.subHeaders && h.subHeaders.length) {\n                h.subHeaders.map(recurseHeader)\n              }\n              leafHeaders.push(h)\n            }\n\n            recurseHeader(header)\n\n            return leafHeaders as Header<TGenerics>[]\n          },\n          getHeaderProps: userProps =>\n            instance.getHeaderProps(header.id, userProps)!,\n          getFooterProps: userProps =>\n            instance.getFooterProps(header.id, userProps)!,\n          renderHeader: () =>\n            column.header\n              ? instance.render(column.header, {\n                  instance,\n                  header: header as Header<TGenerics>,\n                  column,\n                })\n              : null,\n          renderFooter: () =>\n            column.footer\n              ? instance.render(column.footer, {\n                  instance,\n                  header: header as Header<TGenerics>,\n                  column,\n                })\n              : null,\n        }\n\n        // Yes, we have to convert instance to unknown, because we know more than the compiler here.\n        return Object.assign(\n          header,\n          ColumnSizing.createHeader(header as Header<TGenerics>, instance)\n        ) as Header<TGenerics>\n      },\n\n      // Header Groups\n\n      getHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, left, right) => {\n          const leftColumns = leafColumns.filter(column =>\n            left?.includes(column.id)\n          )\n          const rightColumns = leafColumns.filter(column =>\n            right?.includes(column.id)\n          )\n          const centerColumns = leafColumns.filter(\n            column => !left?.includes(column.id) && !right?.includes(column.id)\n          )\n          const headerGroups = buildHeaderGroups(\n            allColumns,\n            [...leftColumns, ...centerColumns, ...rightColumns],\n            instance\n          )\n\n          return headerGroups\n        },\n        {\n          key: 'getHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, left, right) => {\n          leafColumns = leafColumns.filter(\n            column => !left?.includes(column.id) && !right?.includes(column.id)\n          )\n          return buildHeaderGroups(allColumns, leafColumns, instance, 'center')\n        },\n        {\n          key: 'getCenterHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n        ],\n        (allColumns, leafColumns, left) => {\n          leafColumns = leafColumns.filter(column => left?.includes(column.id))\n          return buildHeaderGroups(allColumns, leafColumns, instance, 'left')\n        },\n        {\n          key: 'getLeftHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, right) => {\n          leafColumns = leafColumns.filter(column => right?.includes(column.id))\n          return buildHeaderGroups(allColumns, leafColumns, instance, 'right')\n        },\n        {\n          key: 'getRightHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Footer Groups\n\n      getFooterGroups: memo(\n        () => [instance.getHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: 'getFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftFooterGroups: memo(\n        () => [instance.getLeftHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: 'getLeftFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterFooterGroups: memo(\n        () => [instance.getCenterHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: 'getCenterFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightFooterGroups: memo(\n        () => [instance.getRightHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: 'getRightFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Flat Headers\n\n      getFlatHeaders: memo(\n        () => [instance.getHeaderGroups()],\n        headerGroups => {\n          return headerGroups\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: 'getFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftFlatHeaders: memo(\n        () => [instance.getLeftHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: 'getLeftFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterFlatHeaders: memo(\n        () => [instance.getCenterHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: 'getCenterFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightFlatHeaders: memo(\n        () => [instance.getRightHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: 'getRightFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Leaf Headers\n\n      getCenterLeafHeaders: memo(\n        () => [instance.getCenterFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: 'getCenterLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftLeafHeaders: memo(\n        () => [instance.getLeftFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: 'getLeftLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightLeafHeaders: memo(\n        () => [instance.getRightFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: 'getRightLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeafHeaders: memo(\n        () => [\n          instance.getLeftHeaderGroups(),\n          instance.getCenterHeaderGroups(),\n          instance.getRightHeaderGroups(),\n        ],\n        (left, center, right) => {\n          return [\n            ...(left[0]?.headers ?? []),\n            ...(center[0]?.headers ?? []),\n            ...(right[0]?.headers ?? []),\n          ]\n            .map(header => {\n              return header.getLeafHeaders()\n            })\n            .flat()\n        },\n        {\n          key: 'getLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getHeader: (id: string) => {\n        const header = [\n          ...instance.getFlatHeaders(),\n          ...instance.getCenterFlatHeaders(),\n          ...instance.getLeftFlatHeaders(),\n          ...instance.getRightFlatHeaders(),\n        ].find(d => d.id === id)\n\n        if (!header) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`Could not find header with id: ${id}`)\n          }\n          throw new Error()\n        }\n\n        return header\n      },\n\n      getHeaderGroupProps: (id, userProps) => {\n        const headerGroup = instance.getHeaderGroups().find(d => d.id === id)\n\n        if (!headerGroup) {\n          return\n        }\n\n        return propGetter(\n          {\n            key: headerGroup.id,\n            role: 'row',\n          },\n          userProps\n        )\n      },\n\n      getFooterGroupProps: (id, userProps) => {\n        const headerGroup = instance.getFooterGroups().find(d => d.id === id)\n\n        if (!headerGroup) {\n          return\n        }\n\n        const initialProps = {\n          key: headerGroup.id,\n          role: 'row',\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getHeaderProps: (id, userProps) => {\n        const header = instance.getHeader(id)\n\n        if (!header) {\n          throw new Error()\n        }\n\n        const initialProps: HeaderProps = {\n          key: header.id,\n          role: 'columnheader',\n          colSpan: header.colSpan,\n          rowSpan: header.rowSpan,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getFooterProps: (id, userProps) => {\n        const header = instance.getHeader(id)\n\n        const initialProps: FooterProps = {\n          key: header.id,\n          role: 'columnfooter',\n          colSpan: header.colSpan,\n          rowSpan: header.rowSpan,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getTotalWidth: () => {\n        let width = 0\n\n        instance.getVisibleLeafColumns().forEach(column => {\n          width += column.getWidth() ?? 0\n        })\n\n        return width\n      },\n    }\n  },\n}\n\nexport function buildHeaderGroups<TGenerics extends AnyGenerics>(\n  allColumns: Column<TGenerics>[],\n  columnsToGroup: Column<TGenerics>[],\n  instance: TableInstance<TGenerics>,\n  headerFamily?: 'center' | 'left' | 'right'\n) {\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n\n  let maxDepth = 0\n\n  const findMaxDepth = (columns: Column<TGenerics>[], depth = 1) => {\n    maxDepth = Math.max(maxDepth, depth)\n\n    columns\n      .filter(column => column.getIsVisible())\n      .forEach(column => {\n        if (column.columns?.length) {\n          findMaxDepth(column.columns, depth + 1)\n        }\n      }, 0)\n  }\n\n  findMaxDepth(allColumns)\n\n  let headerGroups: HeaderGroup<TGenerics>[] = []\n\n  const createHeaderGroup = (\n    headersToGroup: Header<TGenerics>[],\n    depth: number\n  ) => {\n    // The header group we are creating\n    const headerGroup: HeaderGroup<TGenerics> = {\n      depth,\n      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),\n      headers: [],\n      getHeaderGroupProps: getterValue =>\n        instance.getHeaderGroupProps(`${depth}`, getterValue)!,\n      getFooterGroupProps: getterValue =>\n        instance.getFooterGroupProps(`${depth}`, getterValue)!,\n    }\n\n    // The parent columns we're going to scan next\n    const parentHeaders: Header<TGenerics>[] = []\n\n    // Scan each column for parents\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n\n      const latestParentHeader = [...parentHeaders].reverse()[0]\n\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth\n\n      let column: Column<TGenerics>\n      let isPlaceholder = false\n\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column\n        isPlaceholder = true\n      }\n\n      const header = instance.createHeader(column, {\n        id: [headerFamily, depth, column.id, headerToGroup?.id]\n          .filter(Boolean)\n          .join('_'),\n        isPlaceholder,\n        placeholderId: isPlaceholder\n          ? `${parentHeaders.filter(d => d.column === column).length}`\n          : undefined,\n        depth,\n      })\n\n      if (!latestParentHeader || latestParentHeader.column !== header.column) {\n        header.subHeaders.push(headerToGroup)\n        parentHeaders.push(header)\n      } else {\n        latestParentHeader.subHeaders.push(headerToGroup)\n      }\n\n      // if (!headerToGroup.isPlaceholder) {\n      //   headerToGroup.column.header = headerToGroup;\n      // }\n\n      headerGroup.headers.push(headerToGroup)\n    })\n\n    headerGroups.push(headerGroup)\n\n    if (depth > 0) {\n      createHeaderGroup(parentHeaders, depth - 1)\n    }\n  }\n\n  const bottomHeaders = columnsToGroup.map(column =>\n    instance.createHeader(column, {\n      depth: maxDepth,\n    })\n  )\n\n  createHeaderGroup(bottomHeaders, maxDepth - 1)\n\n  headerGroups.reverse()\n\n  // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = (headers: Header<TGenerics>[]) => {\n    const filteredHeaders = headers.filter(header =>\n      header.column.getIsVisible()\n    )\n\n    return filteredHeaders.map(header => {\n      let colSpan = 0\n      let rowSpan = 0\n      let childRowSpans = [0]\n\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = []\n\n        recurseHeadersForSpans(header.subHeaders).forEach(\n          ({ colSpan: childColSpan, rowSpan: childRowSpan }) => {\n            colSpan += childColSpan\n            childRowSpans.push(childRowSpan)\n          }\n        )\n      } else {\n        colSpan = 1\n      }\n\n      const minChildRowSpan = Math.min(...childRowSpans)\n      rowSpan = rowSpan + minChildRowSpan\n\n      header.colSpan = colSpan > 0 ? colSpan : undefined\n      header.rowSpan = rowSpan > 0 ? rowSpan : undefined\n\n      return { colSpan, rowSpan }\n    })\n  }\n\n  recurseHeadersForSpans(headerGroups[0]?.headers ?? [])\n\n  return headerGroups\n}\n","import {\n  flattenBy,\n  functionalUpdate,\n  propGetter,\n  memo,\n  RequiredKeys,\n} from './utils'\n\nimport {\n  Updater,\n  PropGetterValue,\n  Options,\n  TableState,\n  ColumnDef,\n  Row,\n  Column,\n  Cell,\n  Header,\n  AccessorFn,\n  HeaderRenderProps,\n  TableProps,\n  TableBodyProps,\n  PropGetter,\n  Getter,\n  RowProps,\n  CellProps,\n  TableInstance,\n  RowValues,\n  PartialGenerics,\n  CoreCell,\n  Renderable,\n  UseRenderer,\n  RowModel,\n  TableFeature,\n  AnyGenerics,\n} from './types'\n\nimport { ColumnSizing } from './features/ColumnSizing'\nimport { Expanding } from './features/Expanding'\nimport { Filters } from './features/Filters'\nimport { Grouping } from './features/Grouping'\nimport { Ordering } from './features/Ordering'\nimport { Pagination } from './features/Pagination'\nimport { Pinning } from './features/Pinning'\nimport { RowSelection } from './features/RowSelection'\nimport { Sorting } from './features/Sorting'\nimport { Visibility } from './features/Visibility'\nimport { Headers } from './features/Headers'\n\nconst features: TableFeature[] = [\n  Headers,\n  Visibility,\n  Ordering,\n  Pinning,\n  Filters,\n  Sorting,\n  Grouping,\n  Expanding,\n  Pagination,\n  RowSelection,\n  ColumnSizing,\n]\n\nexport type CoreOptions<TGenerics extends AnyGenerics> = {\n  data: TGenerics['Row'][]\n  columns: ColumnDef<TGenerics>[]\n  state: Partial<TableState>\n  onStateChange: (updater: Updater<TableState>) => void\n  render: TGenerics['Render']\n  debugAll?: boolean\n  debugTable?: boolean\n  debugHeaders?: boolean\n  debugColumns?: boolean\n  debugRows?: boolean\n  defaultColumn?: Partial<ColumnDef<TGenerics>>\n  initialState?: Partial<TableState>\n  getSubRows?: (\n    originalRow: TGenerics['Row'],\n    index: number\n  ) => TGenerics['Row'][]\n  getRowId?: (\n    originalRow: TGenerics['Row'],\n    index: number,\n    parent?: Row<TGenerics>\n  ) => string\n  autoResetAll?: boolean\n}\n\nexport type TableCore<TGenerics extends AnyGenerics> = {\n  initialState: TableState\n  reset: () => void\n  options: RequiredKeys<Options<TGenerics>, 'state'>\n  setOptions: (newOptions: Updater<Options<TGenerics>>) => void\n  getRowId: (\n    _: TGenerics['Row'],\n    index: number,\n    parent?: Row<TGenerics>\n  ) => string\n  getState: () => TableState\n  setState: (updater: Updater<TableState>) => void\n  getDefaultColumn: () => Partial<ColumnDef<TGenerics>>\n  getColumnDefs: () => ColumnDef<TGenerics>[]\n  createColumn: (\n    columnDef: ColumnDef<TGenerics>,\n    depth: number,\n    parent?: Column<TGenerics>\n  ) => Column<TGenerics>\n  getAllColumns: () => Column<TGenerics>[]\n  getAllFlatColumns: () => Column<TGenerics>[]\n  getAllFlatColumnsById: () => Record<string, Column<TGenerics>>\n  getAllLeafColumns: () => Column<TGenerics>[]\n  getColumn: (columnId: string) => Column<TGenerics>\n  getTotalWidth: () => number\n  createCell: (\n    row: Row<TGenerics>,\n    column: Column<TGenerics>,\n    value: any\n  ) => Cell<TGenerics>\n  createRow: (\n    id: string,\n    original: TGenerics['Row'] | undefined,\n    rowIndex: number,\n    depth: number,\n    values: Record<string, any>\n  ) => Row<TGenerics>\n  getCoreRowModel: () => RowModel<TGenerics>\n  getRowModel: () => RowModel<TGenerics>\n  getRow: (id: string) => Row<TGenerics>\n  getCell: (rowId: string, columnId: string) => Cell<TGenerics>\n  getTableProps: PropGetter<TableProps>\n  getTableBodyProps: PropGetter<TableBodyProps>\n  getRowProps: <TGetter extends Getter<RowProps>>(\n    rowId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<RowProps, TGetter>\n  getCellProps: <TGetter extends Getter<CellProps>>(\n    rowId: string,\n    columnId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<CellProps, TGetter>\n  getTableWidth: () => number\n  getLeftTableWidth: () => number\n  getCenterTableWidth: () => number\n  getRightTableWidth: () => number\n  render: <TProps>(\n    template: Renderable<TGenerics, TProps>,\n    props: TProps\n  ) => string | null | ReturnType<UseRenderer<TGenerics>>\n}\n\nexport type CoreRow<TGenerics extends AnyGenerics> = {\n  id: string\n  index: number\n  original?: TGenerics['Row']\n  depth: number\n  values: RowValues\n  subRows: Row<TGenerics>[]\n  getLeafRows: () => Row<TGenerics>[]\n  getRowProps: PropGetter<RowProps>\n  originalSubRows?: TGenerics['Row'][]\n  getAllCells: () => Cell<TGenerics>[]\n  getAllCellsByColumnId: () => Record<string, Cell<TGenerics>>\n}\n\nexport type CoreColumnDef<TGenerics extends AnyGenerics> = {\n  id: string\n  accessorKey?: string & keyof TGenerics['Row']\n  accessorFn?: AccessorFn<TGenerics['Row']>\n  columns?: ColumnDef<TGenerics>[]\n  header?: Renderable<\n    TGenerics,\n    {\n      instance: TableInstance<TGenerics>\n      header: Header<TGenerics>\n      column: Column<TGenerics>\n    }\n  >\n  footer?: Renderable<\n    TGenerics,\n    {\n      instance: TableInstance<TGenerics>\n      header: Header<TGenerics>\n      column: Column<TGenerics>\n    }\n  >\n  cell?: Renderable<\n    TGenerics,\n    {\n      instance: TableInstance<TGenerics>\n      row: Row<TGenerics>\n      column: Column<TGenerics>\n      cell: Cell<TGenerics>\n      value: TGenerics['Value']\n    }\n  >\n  meta?: TGenerics['ColumnMeta']\n}\n// & GeneratedProperties<true>\n\nexport type CoreColumnDefType = 'data' | 'display' | 'group'\n\nexport type CoreColumn<TGenerics extends AnyGenerics> = {\n  id: string\n  depth: number\n  accessorFn?: AccessorFn<TGenerics['Row']>\n  columnDef: ColumnDef<TGenerics>\n  columnDefType: CoreColumnDefType\n  getWidth: () => number\n  columns: Column<TGenerics>[]\n  parent?: Column<TGenerics>\n  getFlatColumns: () => Column<TGenerics>[]\n  getLeafColumns: () => Column<TGenerics>[]\n}\n\nexport function createTableInstance<TGenerics extends AnyGenerics>(\n  options: Options<TGenerics>\n): TableInstance<TGenerics> {\n  if (options.debugAll || options.debugTable) {\n    console.info('Creating Table Instance...')\n  }\n\n  let instance = {} as TableInstance<TGenerics>\n\n  const defaultOptions = features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.getDefaultOptions?.(instance))\n  }, {})\n\n  const buildOptions = (options: Options<TGenerics>) => ({\n    ...defaultOptions,\n    ...options,\n  })\n\n  instance.options = buildOptions(options)\n\n  const initialState = {\n    ...features.reduce((obj, feature) => {\n      return Object.assign(obj, feature.getInitialState?.())\n    }, {}),\n    ...(options.initialState ?? {}),\n  } as TableState\n\n  const finalInstance: TableInstance<TGenerics> = {\n    ...instance,\n    ...features.reduce((obj, feature) => {\n      return Object.assign(obj, feature.getInstance?.(instance))\n    }, {}),\n    initialState,\n    reset: () => {\n      instance.setState(instance.initialState)\n    },\n    setOptions: updater => {\n      instance.options = buildOptions(\n        functionalUpdate(updater, instance.options)\n      )\n    },\n    render: (template, props) => {\n      if (typeof instance.options.render === 'function') {\n        return instance.options.render(template, props)\n      }\n\n      if (typeof template === 'function') {\n        return (template as Function)(props)\n      }\n\n      return template\n    },\n\n    getRowId: (_: TGenerics['Row'], index: number, parent?: Row<TGenerics>) =>\n      `${parent ? [parent.id, index].join('.') : index}`,\n\n    getState: () => {\n      return instance.options.state as TableState\n    },\n\n    setState: (updater: Updater<TableState>) => {\n      instance.options.onStateChange?.(updater)\n    },\n\n    getDefaultColumn: memo(\n      () => [instance.options.defaultColumn],\n      defaultColumn => {\n        defaultColumn = (defaultColumn ?? {}) as Partial<ColumnDef<TGenerics>>\n\n        return {\n          header: (props: HeaderRenderProps<Header<TGenerics>>) =>\n            props.header.column.id,\n          footer: (props: HeaderRenderProps<Header<TGenerics>>) =>\n            props.header.column.id,\n          cell: ({ value = '' }: { value: any }): JSX.Element =>\n            typeof value === 'boolean' ? value.toString() : value,\n          ...features.reduce((obj, feature) => {\n            return Object.assign(obj, feature.getDefaultColumn?.())\n          }, {}),\n          ...defaultColumn,\n        } as Partial<ColumnDef<TGenerics>>\n      },\n      {\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n        key: 'getDefaultColumn',\n      }\n    ),\n\n    getColumnDefs: () => instance.options.columns,\n\n    createColumn: (\n      columnDef: ColumnDef<TGenerics> & { columnDefType?: CoreColumnDefType },\n      depth: number,\n      parent\n    ) => {\n      const defaultColumn = instance.getDefaultColumn()\n\n      let id =\n        columnDef.id ??\n        columnDef.accessorKey ??\n        (typeof columnDef.header === 'string' ? columnDef.header : undefined)\n\n      let accessorFn: AccessorFn<TGenerics['Row']> | undefined\n\n      if (columnDef.accessorFn) {\n        accessorFn = columnDef.accessorFn\n      } else if (columnDef.accessorKey) {\n        accessorFn = (originalRow?: TGenerics['Row']) =>\n          (originalRow as any)[columnDef.accessorKey]\n      }\n\n      if (!id) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            columnDef.accessorFn\n              ? `Columns require an id when using an accessorFn`\n              : `Columns require an id when using a non-string header`\n          )\n        }\n        throw new Error()\n      }\n\n      let column: CoreColumn<TGenerics> = {\n        ...defaultColumn,\n        ...columnDef,\n        id: `${id}`,\n        accessorFn,\n        parent: parent as any,\n        depth,\n        columnDef,\n        columnDefType: columnDef.columnDefType as CoreColumnDefType,\n        columns: [],\n        getWidth: () => instance.getColumnWidth(column.id),\n        getFlatColumns: memo(\n          () => [true],\n          () => {\n            return [\n              column as Column<TGenerics>,\n              ...column.columns?.flatMap(d => d.getFlatColumns()),\n            ]\n          },\n          {\n            key: 'column.getFlatColumns',\n            debug: () =>\n              instance.options.debugAll ?? instance.options.debugColumns,\n          }\n        ),\n        getLeafColumns: memo(\n          () => [instance.getOrderColumnsFn()],\n          orderColumns => {\n            if (column.columns?.length) {\n              let leafColumns = column.columns.flatMap(column =>\n                column.getLeafColumns()\n              )\n\n              return orderColumns(leafColumns)\n            }\n\n            return [column as Column<TGenerics>]\n          },\n          {\n            key: 'column.getLeafColumns',\n            debug: () =>\n              instance.options.debugAll ?? instance.options.debugColumns,\n          }\n        ),\n      }\n\n      column = features.reduce((obj, feature) => {\n        return Object.assign(obj, feature.createColumn?.(column, instance))\n      }, column)\n\n      // Yes, we have to convert instance to uknown, because we know more than the compiler here.\n      return column as Column<TGenerics>\n    },\n\n    getAllColumns: memo(\n      () => [instance.getColumnDefs()],\n      columnDefs => {\n        const recurseColumns = (\n          columnDefs: ColumnDef<TGenerics>[],\n          parent?: Column<TGenerics>,\n          depth = 0\n        ): Column<TGenerics>[] => {\n          return columnDefs.map(columnDef => {\n            const column = instance.createColumn(columnDef, depth, parent)\n\n            column.columns = columnDef.columns\n              ? recurseColumns(columnDef.columns, column, depth + 1)\n              : []\n\n            return column\n          })\n        }\n\n        return recurseColumns(columnDefs)\n      },\n      {\n        key: 'getAllColumns',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    ),\n\n    getAllFlatColumns: memo(\n      () => [instance.getAllColumns()],\n      allColumns => {\n        return allColumns.flatMap(column => {\n          return column.getFlatColumns()\n        })\n      },\n      {\n        key: 'getAllFlatColumns',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    ),\n\n    getAllFlatColumnsById: memo(\n      () => [instance.getAllFlatColumns()],\n      flatColumns => {\n        return flatColumns.reduce((acc, column) => {\n          acc[column.id] = column\n          return acc\n        }, {} as Record<string, Column<TGenerics>>)\n      },\n      {\n        key: 'getAllFlatColumnsById',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    ),\n\n    getAllLeafColumns: memo(\n      () => [instance.getAllColumns(), instance.getOrderColumnsFn()],\n      (allColumns, orderColumns) => {\n        let leafColumns = allColumns.flatMap(column => column.getLeafColumns())\n        return orderColumns(leafColumns)\n      },\n      {\n        key: 'getAllLeafColumns',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    ),\n\n    getColumn: columnId => {\n      const column = instance.getAllFlatColumnsById()[columnId]\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`[Table] Column with id ${columnId} does not exist.`)\n        }\n        throw new Error()\n      }\n\n      return column\n    },\n\n    createCell: (row, column, value) => {\n      const cell: CoreCell<TGenerics> = {\n        id: `${row.id}_${column.id}`,\n        rowId: row.id,\n        columnId: column.id,\n        row,\n        column,\n        value,\n        getCellProps: userProps =>\n          instance.getCellProps(row.id, column.id, userProps)!,\n        renderCell: () =>\n          column.cell\n            ? instance.render(column.cell, {\n                instance,\n                column,\n                row,\n                cell: cell as Cell<TGenerics>,\n                value,\n              })\n            : null,\n      }\n\n      features.forEach(feature => {\n        Object.assign(\n          cell,\n          feature.createCell?.(\n            cell as Cell<TGenerics>,\n            column,\n            row as Row<TGenerics>,\n            instance\n          )\n        )\n      }, {})\n\n      return cell as Cell<TGenerics>\n    },\n\n    createRow: (id, original, rowIndex, depth, values) => {\n      let row: CoreRow<TGenerics> = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        values,\n        subRows: [],\n        getLeafRows: () => flattenBy(row.subRows, d => d.subRows),\n        getRowProps: userProps => instance.getRowProps(row.id, userProps)!,\n        getAllCells: undefined!,\n        getAllCellsByColumnId: undefined!,\n      }\n\n      row.getAllCells = memo(\n        () => [instance.getAllLeafColumns()],\n        leafColumns => {\n          return leafColumns.map(column => {\n            return instance.createCell(\n              row as Row<TGenerics>,\n              column,\n              row.values[column.id]\n            )\n          })\n        },\n        {\n          key: process.env.NODE_ENV !== 'production' ? 'row.getAllCells' : '',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      )\n\n      row.getAllCellsByColumnId = memo(\n        () => [row.getAllCells()],\n        allCells => {\n          return allCells.reduce((acc, cell) => {\n            acc[cell.columnId] = cell\n            return acc\n          }, {} as Record<string, Cell<TGenerics>>)\n        },\n        {\n          key: 'row.getAllCellsByColumnId',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      )\n\n      for (let i = 0; i < features.length; i++) {\n        const feature = features[i]\n        Object.assign(row, feature.createRow?.(row, instance))\n      }\n\n      return row as Row<TGenerics>\n    },\n\n    getCoreRowModel: memo(\n      () => [instance.options.data],\n      (\n        data\n      ): {\n        rows: Row<TGenerics>[]\n        flatRows: Row<TGenerics>[]\n        rowsById: Record<string, Row<TGenerics>>\n      } => {\n        // Access the row model using initial columns\n        const rows: Row<TGenerics>[] = []\n        const flatRows: Row<TGenerics>[] = []\n        const rowsById: Record<string, Row<TGenerics>> = {}\n\n        const leafColumns = instance.getAllLeafColumns()\n\n        const accessRow = (\n          originalRow: TGenerics['Row'],\n          rowIndex: number,\n          depth = 0,\n          parentRows: Row<TGenerics>[],\n          parent?: Row<TGenerics>\n        ) => {\n          const id = instance.getRowId(originalRow, rowIndex, parent)\n\n          if (!id) {\n            if (process.env.NODE_ENV !== 'production') {\n              throw new Error(`getRowId expected an ID, but got ${id}`)\n            }\n          }\n\n          const values: Record<string, any> = {}\n\n          for (let i = 0; i < leafColumns.length; i++) {\n            const column = leafColumns[i]\n            if (column && column.accessorFn) {\n              values[column.id] = column.accessorFn(originalRow, rowIndex)\n            }\n          }\n\n          // Make the row\n          const row = instance.createRow(\n            id,\n            originalRow,\n            rowIndex,\n            depth,\n            values\n          )\n\n          // Push instance row into the parentRows array\n          parentRows.push(row)\n          // Keep track of every row in a flat array\n          flatRows.push(row)\n          // Also keep track of every row by its ID\n          rowsById[id] = row\n\n          // Get the original subrows\n          if (instance.options.getSubRows) {\n            const originalSubRows = instance.options.getSubRows(\n              originalRow,\n              rowIndex\n            )\n\n            // Then recursively access them\n            if (originalSubRows?.length) {\n              row.originalSubRows = originalSubRows\n              const subRows: Row<TGenerics>[] = []\n\n              for (let i = 0; i < row.originalSubRows.length; i++) {\n                accessRow(\n                  row.originalSubRows[i] as TGenerics['Row'],\n                  i,\n                  depth + 1,\n                  subRows,\n                  row\n                )\n              }\n              row.subRows = subRows\n            }\n          }\n        }\n\n        for (let i = 0; i < data.length; i++) {\n          accessRow(data[i] as TGenerics['Row'], i, 0, rows)\n        }\n\n        return { rows, flatRows, rowsById }\n      },\n      {\n        key: 'getRowModel',\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {\n          instance._notifyFiltersReset()\n          instance._notifyRowSelectionReset()\n        },\n      }\n    ),\n\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n\n    getRowModel: () => {\n      return instance.getPaginationRowModel()\n    },\n\n    getRow: (id: string) => {\n      const row = instance.getRowModel().rowsById[id]\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(`getRow expected an ID, but got ${id}`)\n        }\n        throw new Error()\n      }\n\n      return row\n    },\n\n    getCell: (rowId: string, columnId: string) => {\n      const row = instance.getRow(rowId)\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(`[Table] could not find row with id ${rowId}`)\n        }\n        throw new Error()\n      }\n\n      const cell = row.getAllCellsByColumnId()[columnId]\n\n      if (!cell) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `[Table] could not find cell ${columnId} in row ${rowId}`\n          )\n        }\n        throw new Error()\n      }\n\n      return cell\n    },\n\n    getTableProps: userProps => {\n      return propGetter(\n        {\n          role: 'table',\n        },\n        userProps\n      )\n    },\n\n    getTableBodyProps: userProps => {\n      return propGetter(\n        {\n          role: 'rowgroup',\n        },\n        userProps\n      )\n    },\n\n    getRowProps: (rowId, userProps) => {\n      const row = instance.getRow(rowId)\n      if (!row) {\n        return\n      }\n\n      return propGetter(\n        {\n          key: row.id,\n          role: 'row',\n        },\n        userProps\n      )\n    },\n\n    getCellProps: (rowId, columnId, userProps) => {\n      const cell = instance.getCell(rowId, columnId)\n\n      if (!cell) {\n        return\n      }\n\n      return propGetter(\n        {\n          key: cell.id,\n          role: 'gridcell',\n        },\n        userProps\n      )\n    },\n\n    getTableWidth: () =>\n      instance.getHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getWidth()\n      }, 0) ?? 0,\n    getLeftTableWidth: () =>\n      instance.getLeftHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getWidth()\n      }, 0) ?? 0,\n    getCenterTableWidth: () =>\n      instance.getCenterHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getWidth()\n      }, 0) ?? 0,\n    getRightTableWidth: () =>\n      instance.getRightHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getWidth()\n      }, 0) ?? 0,\n  }\n\n  instance = Object.assign(instance, finalInstance)\n\n  return instance\n}\n","import { CustomFilterTypes } from './features/Filters'\nimport { CustomAggregationTypes } from './features/Grouping'\nimport { CustomSortingTypes } from './features/Sorting'\nimport {\n  ColumnDef,\n  AccessorFn,\n  PartialGenerics,\n  AnyRender,\n  AnyGenerics,\n} from './types'\nimport { Overwrite, PartialKeys } from './utils'\n\nexport type CreateTableFactory<TGenerics extends AnyGenerics> = <\n  TSubGenerics extends {\n    Row: any\n    ColumnMeta?: object\n  }\n>() => Table<\n  Overwrite<\n    TGenerics,\n    { Row: TSubGenerics['Row']; ColumnMeta: TSubGenerics['ColumnMeta'] }\n  >\n>\n\nexport type CreateTableFactoryOptions<\n  TRender extends AnyRender,\n  TFilterFns extends CustomFilterTypes<any>,\n  TSortingFns extends CustomSortingTypes<any>,\n  TAggregationFns extends CustomAggregationTypes<any>\n> = {\n  render: TRender\n  filterFns?: TFilterFns\n  sortingFns?: TSortingFns\n  aggregationFns?: TAggregationFns\n}\n\nexport type Table<TGenerics extends AnyGenerics> = {\n  generics: TGenerics\n  __options: CreateTableFactoryOptions<any, any, any, any>\n  createColumns: <TColumnDef extends ColumnDef<any>>(\n    columns: TColumnDef[]\n  ) => TColumnDef[]\n  createGroup: (\n    column: Overwrite<\n      | Overwrite<\n          ColumnDef<any>,\n          {\n            header: string\n            id?: string\n          }\n        >\n      | Overwrite<\n          ColumnDef<any>,\n          {\n            id: string\n            header?: string | ((...any: any) => any)\n          }\n        >,\n      {\n        accessorFn?: never\n        accessorKey?: never\n        columns?: ColumnDef<any>[]\n      }\n    >\n  ) => ColumnDef<TGenerics>\n  createDisplayColumn: (\n    column: Overwrite<\n      PartialKeys<ColumnDef<TGenerics>, 'accessorFn' | 'accessorKey'>,\n      {\n        columns?: ColumnDef<any>[]\n      }\n    >\n  ) => ColumnDef<TGenerics>\n  createDataColumn: <\n    TAccessor extends AccessorFn<TGenerics['Row']> | keyof TGenerics['Row']\n  >(\n    accessor: TAccessor,\n    column: Overwrite<\n      TAccessor extends (...args: any[]) => any\n        ? // Accessor Fn\n          ColumnDef<Overwrite<TGenerics, { Value: ReturnType<TAccessor> }>>\n        : TAccessor extends keyof TGenerics['Row']\n        ? // Accessor Key\n          Overwrite<\n            ColumnDef<\n              Overwrite<TGenerics, { Value: TGenerics['Row'][TAccessor] }>\n            >,\n            {\n              id?: string\n            }\n          >\n        : never,\n      {\n        accessorFn?: never\n        accessorKey?: never\n        columns?: ColumnDef<any>[]\n      }\n    >\n  ) => ColumnDef<TGenerics>\n}\n\ntype InitTable<TRender extends AnyRender> = {\n  createTableFactory: <TGenerics extends AnyGenerics>(\n    options: CreateTableFactoryOptions<TRender, any, any, any>\n  ) => CreateTableFactory<Overwrite<TGenerics, { Render: TRender }>>\n  createTable: CreateTableFactory<\n    Overwrite<PartialGenerics, { Render: TRender }>\n  >\n}\n\n//\n\nexport function init<TRender extends AnyRender>(opts: {\n  render: TRender\n}): InitTable<TRender> {\n  return {\n    createTableFactory: factoryOptions => () =>\n      _createTable(undefined, undefined, { ...factoryOptions, ...opts }),\n    createTable: () => _createTable(undefined, undefined, opts),\n  }\n}\n\nfunction _createTable<TGenerics extends AnyGenerics>(\n  _: undefined,\n  __: undefined,\n  __options: CreateTableFactoryOptions<any, any, any, any>\n): Table<TGenerics> {\n  return {\n    generics: undefined!,\n    __options: __options ?? {\n      render: () => {\n        throw new Error()\n      },\n    },\n    createColumns: columns => columns,\n    createDisplayColumn: column => ({ ...column, columnDefType: 'display' }),\n    createGroup: column => ({ ...column, columnDefType: 'group' } as any),\n    createDataColumn: (accessor, column): any => {\n      column = {\n        ...column,\n        columnDefType: 'data',\n        id: column.id,\n      }\n\n      if (typeof accessor === 'string') {\n        return {\n          ...column,\n          id: column.id ?? accessor,\n          accessorKey: accessor,\n        }\n      }\n\n      if (typeof accessor === 'function') {\n        return {\n          ...column,\n          accessorFn: accessor,\n        }\n      }\n\n      throw new Error('Invalid accessor')\n    },\n  }\n}\n","import { AnyGenerics, Row, RowModel, TableInstance } from '../types'\n\nexport function filterRowModelFromLeafs<TGenerics extends AnyGenerics>(\n  rowsToFilter: Row<TGenerics>[],\n  filterRows: (\n    rowsToFilter: Row<TGenerics>[],\n    depth: number\n  ) => Row<TGenerics>[],\n  instance: TableInstance<TGenerics>\n): RowModel<TGenerics> {\n  const newFilteredFlatRows: Row<TGenerics>[] = []\n  const newFilteredRowsById: Record<string, Row<TGenerics>> = {}\n\n  const recurseFilterRows = (rowsToFilter: Row<TGenerics>[], depth = 0) => {\n    rowsToFilter = rowsToFilter.slice()\n\n    // Filter from children up first\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      const row = rowsToFilter[i]\n\n      if (!row.subRows?.length) {\n        continue\n      }\n\n      rowsToFilter[i] = instance.createRow(\n        row.id,\n        row.original,\n        row.index,\n        row.depth,\n        row.values\n      )\n\n      rowsToFilter[i].subRows = recurseFilterRows(row.subRows, depth + 1)\n\n      if (!rowsToFilter[i].subRows.length) {\n        rowsToFilter.splice(i, 1)\n        i--\n      }\n    }\n\n    rowsToFilter = filterRows(rowsToFilter, depth)\n\n    // Apply the filter to any subRows\n    rowsToFilter.forEach(row => {\n      newFilteredFlatRows.push(row)\n      newFilteredRowsById[row.id] = row\n    })\n\n    return rowsToFilter\n  }\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n\nexport function filterRowModelFromRoot<TGenerics extends AnyGenerics>(\n  rowsToFilter: Row<TGenerics>[],\n  filterRows: (\n    rowsToFilter: Row<TGenerics>[],\n    depth: number\n  ) => Row<TGenerics>[],\n  instance: TableInstance<TGenerics>\n): RowModel<TGenerics> {\n  const newFilteredFlatRows: Row<TGenerics>[] = []\n  const newFilteredRowsById: Record<string, Row<TGenerics>> = {}\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (rowsToFilter: Row<TGenerics>[], depth = 0) => {\n    // Filter from parents downward first\n    rowsToFilter = filterRows(rowsToFilter, depth)\n\n    // Apply the filter to any subRows\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      const row = rowsToFilter[i]\n\n      newFilteredFlatRows.push(row)\n      newFilteredRowsById[row.id] = row\n\n      if (!row.subRows?.length) {\n        rowsToFilter.splice(i, 1)\n        i--\n        continue\n      }\n\n      rowsToFilter[i] = instance.createRow(\n        row.id,\n        row.original,\n        row.index,\n        row.depth,\n        row.values\n      )\n\n      rowsToFilter[i].subRows = recurseFilterRows(row.subRows, depth + 1)\n    }\n\n    return rowsToFilter\n  }\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n","import {\n  TableInstance,\n  Row,\n  RowModel,\n  AnyGenerics,\n  PartialGenerics,\n} from '../types'\n\nexport function expandRowsFn<TGenerics extends AnyGenerics>(\n  instance: TableInstance<TGenerics>,\n  sortedRowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const expandedRows: Row<TGenerics>[] = []\n\n  const handleRow = (row: Row<TGenerics>) => {\n    expandedRows.push(row)\n\n    if (\n      instance.options.expandSubRows &&\n      row.subRows?.length &&\n      instance.getIsRowExpanded(row.id)\n    ) {\n      row.subRows.forEach(handleRow)\n    }\n  }\n\n  sortedRowModel.rows.forEach(handleRow)\n\n  return {\n    rows: expandedRows,\n    flatRows: sortedRowModel.flatRows,\n    rowsById: sortedRowModel.rowsById,\n  }\n}\n","import { AnyGenerics, TableInstance, Row, RowModel } from '../types'\nimport {\n  filterRowModelFromLeafs,\n  filterRowModelFromRoot,\n} from './filterRowsUtils'\n\nexport function columnFilterRowsFn<TGenerics extends AnyGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const columnFilters = instance.getState().columnFilters\n  const filterFromLeafRows = instance.options.filterFromLeafRows\n\n  const filterRows = (rowsToFilter: Row<TGenerics>[], depth: number) => {\n    for (let i = 0; i < columnFilters.length; i++) {\n      const { id: columnId, value: filterValue } = columnFilters[i]\n      // Find the columnFilters column\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`Table: Could not find a column with id: ${columnId}`)\n        }\n        throw new Error()\n      }\n\n      if (depth === 0) {\n        const preFilteredRows = [...rowsToFilter]\n        column.getPreFilteredRows = () => preFilteredRows\n      }\n\n      const filterFn = instance.getColumnFilterFn(column.id)\n\n      if (!filterFn) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Could not find a valid 'column.filterType' for column with the ID: ${column.id}.`\n          )\n        }\n        continue\n      }\n\n      // Pass the rows, id, filterValue and column to the filterFn\n      // to get the filtered rows back\n      rowsToFilter = filterFn(rowsToFilter, [columnId], filterValue)\n    }\n\n    return rowsToFilter\n  }\n\n  if (filterFromLeafRows) {\n    return filterRowModelFromLeafs(rowModel.rows, filterRows, instance)\n  }\n\n  return filterRowModelFromRoot(rowModel.rows, filterRows, instance)\n}\n","import { TableInstance, Row, RowModel, AnyGenerics } from '../types'\nimport {\n  filterRowModelFromLeafs,\n  filterRowModelFromRoot,\n} from './filterRowsUtils'\n\nexport function globalFilterRowsFn<TGenerics extends AnyGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const globalFilter = instance.getState().globalFilter\n\n  const filterFromLeafRows = instance.options.filterFromLeafRows\n\n  const filterFn = instance.getGlobalFilterFn()\n\n  if (!filterFn) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Could not find a valid 'globalFilterType'`)\n    }\n    return rowModel\n  }\n\n  const filterableColumns = instance\n    .getAllLeafColumns()\n    .filter(column => column.getCanGlobalFilter())\n\n  const filterableColumnIds = filterableColumns.map(d => d.id)\n\n  const filterRows = (rows: Row<TGenerics>[]) => {\n    return filterFn(rows, filterableColumnIds, globalFilter)\n  }\n\n  if (filterFromLeafRows) {\n    filterRowModelFromLeafs(rowModel.rows, filterRows, instance)\n  }\n\n  return filterRowModelFromRoot(rowModel.rows, filterRows, instance)\n}\n","import {\n  TableInstance,\n  Row,\n  RowModel,\n  AnyGenerics,\n  PartialGenerics,\n} from '../types'\nimport { flattenBy } from '../utils'\n\nexport function groupRowsFn<TGenerics extends AnyGenerics>(\n  instance: TableInstance<TGenerics>,\n  sortedRowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const groupingState = instance.getState().grouping\n  // Filter the grouping list down to columns that exist\n  const existingGrouping = groupingState.filter(columnId =>\n    instance.getColumn(columnId)\n  )\n\n  // Find the columns that can or are aggregating\n  // Uses each column to aggregate rows into a single value\n  const aggregateRowsToValues = (\n    leafRows: Row<TGenerics>[],\n    groupedRows: Row<TGenerics>[],\n    depth: number\n  ) => {\n    const values: Record<string, unknown> = {}\n\n    instance.getAllLeafColumns().forEach(column => {\n      // Don't aggregate columns that are in the grouping\n      if (existingGrouping.includes(column.id)) {\n        values[column.id] = groupedRows[0]\n          ? groupedRows[0].values[column.id]\n          : null\n        return\n      }\n\n      // Aggregate the values\n      const aggregateFn = instance.getColumnAggregationFn(column.id)\n\n      if (aggregateFn) {\n        values[column.id] = aggregateFn(\n          () =>\n            leafRows.map(row => {\n              let columnValue = row.values[column.id]\n\n              if (!depth && column.aggregateValue) {\n                columnValue = column.aggregateValue(columnValue)\n              }\n\n              return columnValue\n            }),\n          () => groupedRows.map(row => row.values[column.id])\n        )\n      } else if (column.aggregationType) {\n        console.info({ column })\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `Table: Invalid column.aggregateType option for column listed above`\n            : ''\n        )\n      } else {\n        values[column.id] = null\n      }\n    })\n\n    return values\n  }\n\n  const groupedFlatRows: Row<TGenerics>[] = []\n  const groupedRowsById: Record<string, Row<TGenerics>> = {}\n  // const onlyGroupedFlatRows: Row[] = [];\n  // const onlyGroupedRowsById: Record<RowId, Row> = {};\n  // const nonGroupedFlatRows: Row[] = [];\n  // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n  // Recursively group the data\n  const groupUpRecursively = (\n    rows: Row<TGenerics>[],\n    depth = 0,\n    parentId: string\n  ) => {\n    // This is the last level, just return the rows\n    if (depth === existingGrouping.length) {\n      return rows\n    }\n\n    const columnId = existingGrouping[depth]!\n\n    // Group the rows together for this level\n    const rowGroupsMap = groupBy(rows, columnId)\n\n    // Peform aggregations for each group\n    const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map(\n      ([groupingValue, groupedRows], index) => {\n        let id = `${columnId}:${groupingValue}`\n        id = parentId ? `${parentId}>${id}` : id\n\n        // First, Recurse to group sub rows before aggregation\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n        // Flatten the leaf rows of the rows in this group\n        const leafRows = depth\n          ? flattenBy(groupedRows, row => row.subRows)\n          : groupedRows\n\n        const values = aggregateRowsToValues(leafRows, groupedRows, depth)\n\n        const row = instance.createRow(id, undefined, index, depth, values)\n\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n        })\n\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow)\n          groupedRowsById[subRow.id] = subRow\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        })\n\n        return row\n      }\n    )\n\n    return aggregatedGroupedRows\n  }\n\n  const groupedRows = groupUpRecursively(sortedRowModel.rows, 0, '')\n\n  groupedRows.forEach(subRow => {\n    groupedFlatRows.push(subRow)\n    groupedRowsById[subRow.id] = subRow\n    // if (subRow.getIsGrouped?.()) {\n    //   onlyGroupedFlatRows.push(subRow);\n    //   onlyGroupedRowsById[subRow.id] = subRow;\n    // } else {\n    //   nonGroupedFlatRows.push(subRow);\n    //   nonGroupedRowsById[subRow.id] = subRow;\n    // }\n  })\n\n  return {\n    rows: groupedRows,\n    flatRows: groupedFlatRows,\n    rowsById: groupedRowsById,\n  }\n}\n\nfunction groupBy<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnId: string\n) {\n  const groupMap = new Map<any, Row<TGenerics>[]>()\n\n  return rows.reduce((map, row) => {\n    const resKey = `${row.values[columnId]}`\n    const previous = map.get(resKey)\n    if (!previous) {\n      map.set(resKey, [row])\n    } else {\n      map.set(resKey, [...previous, row])\n    }\n    return map\n  }, groupMap)\n}\n","import { TableInstance, RowModel, AnyGenerics } from '../types'\nimport { expandRowsFn } from './expandRowsFn'\n\nexport function paginateRowsFn<TGenerics extends AnyGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const { pageSize, pageIndex } = instance.getState().pagination\n  let { rows, flatRows, rowsById } = rowModel\n  const pageStart = pageSize * pageIndex\n  const pageEnd = pageStart + pageSize\n\n  rows = rows.slice(pageStart, pageEnd)\n\n  if (!instance.options.paginateExpandedRows) {\n    return expandRowsFn(instance, {\n      rows,\n      flatRows,\n      rowsById,\n    })\n  }\n\n  return {\n    rows,\n    flatRows,\n    rowsById,\n  }\n}\n","import { TableInstance, Row, RowModel, AnyGenerics } from '../types'\nimport { SortingFn } from '../features/Sorting'\n\nexport function sortRowsFn<TGenerics extends AnyGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const sortingState = instance.getState().sorting\n\n  const sortedFlatRows: Row<TGenerics>[] = []\n\n  // Filter out sortings that correspond to non existing columns\n  const availableSorting = sortingState.filter(sort =>\n    instance.getColumnCanSort(sort.id)\n  )\n\n  const columnInfoById: Record<\n    string,\n    {\n      sortUndefined?: false | -1 | 1\n      invertSorting?: boolean\n      sortingFn: SortingFn<TGenerics>\n    }\n  > = {}\n\n  availableSorting.forEach(sortEntry => {\n    const column = instance.getColumn(sortEntry.id)!\n\n    columnInfoById[sortEntry.id] = {\n      sortUndefined: column.sortUndefined,\n      invertSorting: column.invertSorting,\n      sortingFn: instance.getColumnSortingFn(sortEntry.id)!,\n    }\n  })\n\n  const sortData = (rows: Row<TGenerics>[]) => {\n    // This will also perform a stable sorting using the row index\n    // if needed.\n    const sortedData = rows.slice()\n\n    sortedData.sort((rowA, rowB) => {\n      for (let i = 0; i < availableSorting.length; i += 1) {\n        const sortEntry = availableSorting[i]!\n        const columnInfo = columnInfoById[sortEntry.id]!\n        const isDesc = sortEntry?.desc ?? false\n\n        if (columnInfo.sortUndefined) {\n          const aValue = rowA.values[sortEntry.id]\n          const bValue = rowB.values[sortEntry.id]\n\n          const aUndefined = typeof aValue === 'undefined'\n          const bUndefined = typeof bValue === 'undefined'\n\n          if (aUndefined || bUndefined) {\n            return aUndefined && bUndefined\n              ? 0\n              : aUndefined\n              ? columnInfo.sortUndefined\n              : -columnInfo.sortUndefined\n          }\n        }\n\n        // This function should always return in ascending order\n        let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id)\n\n        if (sortInt !== 0) {\n          if (isDesc) {\n            sortInt *= -1\n          }\n\n          if (columnInfo.invertSorting) {\n            sortInt *= -1\n          }\n\n          return sortInt\n        }\n      }\n\n      return rowA.index - rowB.index\n    })\n\n    // If there are sub-rows, sort them\n    sortedData.forEach(row => {\n      sortedFlatRows.push(row)\n      if (!row.subRows || row.subRows.length <= 1) {\n        return\n      }\n      row.subRows = sortData(row.subRows)\n    })\n\n    return sortedData\n  }\n\n  return {\n    rows: sortData(rowModel.rows),\n    flatRows: sortedFlatRows,\n    rowsById: rowModel.rowsById,\n  }\n}\n"],"names":["functionalUpdate","updater","input","makeStateUpdater","key","instance","setState","old","isFunction","d","Function","flattenBy","arr","getChildren","flat","recurse","subArr","forEach","item","push","children","length","propGetter","initial","getter","memo","getDeps","fn","opts","result","deps","depTime","debug","performance","now","newDeps","some","dep","index","resultTime","oldResult","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","map","_","filter","Boolean","reduce","accu","a","b","parent","undefined","defaultColumnSizing","width","minWidth","maxWidth","Number","MAX_SAFE_INTEGER","ColumnSizing","getDefaultColumn","getInitialState","columnSizing","columnSizingInfo","startOffset","startSize","deltaOffset","deltaPercentage","isResizingColumn","columnSizingStart","getDefaultOptions","columnResizeMode","onColumnSizingChange","onColumnSizingInfoChange","getInstance","getColumnWidth","columnId","column","getColumn","Error","columnSize","getState","id","setColumnSizing","options","setColumnSizingInfo","resetColumnSizing","initialState","resetHeaderSizeInfo","resetColumnSize","resetHeaderSize","headerId","header","getHeader","getHeaderCanResize","getColumnCanResize","enableResizing","enableColumnResizing","defaultCanResize","getColumnIsResizing","getHeaderIsResizing","getHeaderResizerProps","userProps","canResize","getCanResize","onResizeStart","e","isTouchStartEvent","touches","getWidth","getLeafHeaders","clientX","updateOffset","eventType","clientXPos","newColumnSizing","headerWidth","onMove","onEnd","mouseEvents","moveHandler","upHandler","document","removeEventListener","touchEvents","cancelable","preventDefault","stopPropagation","passiveIfSupported","passiveEventSupported","passive","addEventListener","title","draggable","role","onMouseDown","persist","onTouchStart","createColumn","getIsResizing","resetSize","createHeader","getResizerProps","passiveSupported","supported","noop","window","err","type","Expanding","expanded","onExpandedChange","autoResetExpanded","expandSubRows","paginateExpandedRows","registered","_notifyExpandedReset","autoResetAll","resetExpanded","setExpanded","toggleRowExpanded","rowId","exists","oldExpanded","Object","keys","getRowModel","rowsById","toggleAllRowsExpanded","getIsAllRowsExpanded","_instance$initialStat2","getIsRowExpanded","row","getPreExpandedRowModel","getRowCanExpand","getRow","enableExpanded","defaultCanExpand","subRows","_row$subRows","getToggleExpandedProps","canExpand","onClick","getToggleAllRowsExpandedProps","getIsSomeRowsExpanded","values","getExpandedDepth","maxDepth","splitId","split","getExpandedRowModel","getGroupedRowModel","expandRowsFn","rowModel","debugAll","debugTable","createRow","toggleExpanded","getIsExpanded","getCanExpand","filterTypes","includesString","includesStringSensitive","equalsString","equalsStringSensitive","arrIncludes","arrIncludesAll","equals","weakEquals","betweenNumberRange","rows","columnIds","filterValue","search","toLowerCase","includes","rowValue","every","val","unsafeMin","unsafeMax","parsedMin","parseFloat","parsedMax","isNaN","Infinity","temp","testFalsey","autoRemove","Filters","filterType","columnFilters","globalFilter","onColumnFiltersChange","onGlobalFilterChange","autoResetColumnFilters","filterFromLeafRows","autoResetGlobalFilter","globalFilterType","getColumnCanGlobalFilterFn","getCoreRowModel","flatRows","_instance$getCoreRowM","getAllCellsByColumnId","_instance$getCoreRowM2","value","getFacetInfo","getPreFilteredRows","preFilteredUniqueValues","Map","preFilteredMinMaxValues","_rows$","_rows$2","i","_rows$i","has","set","get","debugColumns","getCanColumnFilter","getColumnCanColumnFilter","getCanGlobalFilter","getColumnCanGlobalFilter","getColumnFilterIndex","getIsColumnFiltered","getColumnIsFiltered","getColumnFilterValue","setColumnFilterValue","getPreFilteredUniqueValues","getPreFilteredMinMaxValues","_notifyFiltersReset","resetSorting","resetColumnFilters","resetGlobalFilter","getColumnAutoFilterFn","firstRow","Array","isArray","getGlobalAutoFilterFn","getColumnFilterFn","userFilterTypes","getGlobalFilterFn","setColumnFilters","leafColumns","getAllLeafColumns","updateFn","_functionalUpdate","find","shouldAutoRemoveFilter","setGlobalFilter","enableAllFilters","enableColumnFilter","enableFilters","enableColumnFilters","defaultCanFilter","defaultCanColumnFilter","accessorFn","enableGlobalFilter","defaultCanGlobalFilter","_instance$getState$co","_instance$getState$co2","_instance$getState$co4","findIndex","filterFn","previousfilter","newFilter","newFilterObj","getPreFilteredRowModel","getPreColumnFilteredRowModel","getColumnFilteredRowModel","columnFilterRowsFn","columnFiltersFn","columnFilteredRowModel","_instance$getState$co5","getPreGlobalFilteredRowModel","getGlobalFilteredRowModel","globalFilterRowsFn","globalFilterValue","globalFiltersFn","globalFilteredRowModel","_instance$getState$co6","_notifySortingReset","aggregationTypes","sum","_getLeafValues","getChildValues","next","extent","mean","getLeafValues","count","median","leafValues","unique","from","Set","uniqueCount","size","Grouping","aggregationType","grouping","onGroupingChange","autoResetGrouping","groupedColumnMode","getCanGroup","getColumnCanGroup","getGroupedIndex","getColumnGroupedIndex","getIsGrouped","getColumnIsGrouped","toggleGrouping","toggleColumnGrouping","getToggleGroupingProps","_notifyGroupingReset","resetGrouping","getColumnAutoAggregationFn","prototype","toString","call","getColumnAggregationFn","userAggregationTypes","setGrouping","enableGrouping","defaultCanGroup","_instance$getState$gr","_instance$getState$gr2","indexOf","canGroup","getRowIsGrouped","_instance$getRow","groupingColumnId","getPreGroupedRowModel","getSortedRowModel","groupRowsFn","createCell","cell","getIsPlaceholder","getIsAggregated","renderAggregatedCell","template","aggregatedCell","render","orderColumns","nonGroupingColumns","col","groupingColumns","g","Ordering","columnOrder","onColumnOrderChange","setColumnOrder","resetColumnOrder","getOrderColumnsFn","columns","orderedColumns","columnOrderCopy","columnsCopy","targetColumnId","shift","foundIndex","splice","Pagination","pagination","pageCount","pageIndex","pageSize","onPaginationChange","autoResetPageIndex","_notifyPageIndexReset","resetPageIndex","setPagination","safeUpdater","resetPagination","setPageIndex","maxPageIndex","resetPageSize","setPageSize","_instance$initialStat3","_instance$initialStat4","topRowIndex","floor","setPageCount","newPageCount","getPageOptions","pageOptions","fill","getCanPreviousPage","getCanNextPage","getPageCount","ceil","getPrePaginationRowModel","previousPage","nextPage","getPaginationRowModel","paginateRowsFn","_pagination","Pinning","columnPinning","left","right","onColumnPinningChange","getCanPin","getColumnCanPin","getPinnedIndex","getColumnPinnedIndex","getIsPinned","getColumnIsPinned","pin","position","pinColumn","setColumnPinning","resetColumnPinning","getLeafColumns","enablePinning","defaultCanPin","leafColumnIds","isLeft","isRight","_instance$getState$co3","getIsSomeColumnsPinned","RowSelection","rowSelection","onRowSelectionChange","autoResetRowSelection","enableRowSelection","enableMultiRowSelection","enableSubRowSelection","_notifyRowSelectionReset","resetRowSelection","setRowSelection","toggleAllRowsSelected","getIsAllRowsSelected","preGroupedFlatRows","toggleAllPageRowsSelected","getIsAllPageRowsSelected","mutateRowIsSelected","toggleRowSelected","isSelected","getIsSelected","selectedRowIds","getPreSelectedRowModel","getSelectedRowModel","selectRowsFn","getFilteredSelectedRowModel","getGroupedSelectedRowModel","getRowIsSelected","isRowSelected","getRowIsSomeSelected","getRowCanSelect","getRowCanSelectSubRows","getRowCanMultiSelect","preFilteredFlatRows","isAllRowsSelected","paginationFlatRows","isAllPageRowsSelected","getIsSomeRowsSelected","getIsSomePageRowsSelected","getToggleRowSelectedProps","isSomeSelected","getIsSomeSelected","canSelect","getCanSelect","toggleSelected","target","checked","indeterminate","getToggleAllRowsSelectedProps","isSomeRowsSelected","getToggleAllPageRowsSelectedProps","isSomePageRowsSelected","getToggleSelectedProps","getCanMultiSelect","newSelectedFlatRows","newSelectedRowsById","recurseRows","depth","_row$subRows2","selection","allChildrenSelected","someSelected","subRow","reSplitAlphaNumeric","sortTypes","alphanumeric","rowA","rowB","compareAlphanumeric","alphanumericCaseSensitive","text","compareBasic","textCaseSensitive","datetime","getTime","basic","aStr","bStr","aa","bb","an","parseInt","bn","combo","sort","Sorting","sortType","sorting","onSortingChange","autoResetSorting","isMultiSortEvent","shiftKey","getCanSort","getColumnCanSort","getCanMultiSort","getColumnCanMultiSort","getSortIndex","getColumnSortIndex","getIsSorted","getColumnIsSorted","toggleSorting","desc","isMulti","toggleColumnSorting","getToggleSortingProps","getColumnAutoSortingFn","isString","slice","getColumnAutoSortDir","getColumnSortingFn","userSortTypes","setSorting","multi","sortAction","existingSorting","existingIndex","hasDescDefined","newSorting","sortDescFirst","enableSortingRemoval","enableMultiRemove","maxMultiSortColCount","enableSorting","defaultCanSort","enableMultiSort","columnSort","_instance$getState$so","_instance$getState$so3","canSort","getPreSortedRowModel","sortRowsFn","sortingFn","Visibility","columnVisibility","onColumnVisibilityChange","defaultIsVisible","getCanHide","getColumnCanHide","getIsVisible","getColumnIsVisible","toggleVisibility","toggleColumnVisibility","getToggleVisibilityProps","props","getVisibleFlatColumns","getAllFlatColumns","join","allFlatColumns","getVisibleLeafColumns","setColumnVisibility","toggleAllColumnsVisible","getIsAllColumnsVisible","obj","enableHiding","defaultCanHide","getIsSomeColumnsVisible","getToggleAllColumnsVisibilityProps","_e$target","Headers","_getAllVisibleCells","getAllCells","debugRows","getVisibleCells","getLeftVisibleCells","getCenterVisibleCells","getRightVisibleCells","center","allCells","leftAndRight","isPlaceholder","placeholderId","subHeaders","colSpan","rowSpan","leafHeaders","recurseHeader","h","getHeaderProps","getFooterProps","renderHeader","renderFooter","footer","assign","getHeaderGroups","getAllColumns","allColumns","leftColumns","rightColumns","centerColumns","buildHeaderGroups","debugHeaders","getCenterHeaderGroups","getLeftHeaderGroups","getRightHeaderGroups","getFooterGroups","headerGroups","reverse","getLeftFooterGroups","getCenterFooterGroups","getRightFooterGroups","getFlatHeaders","headerGroup","headers","getLeftFlatHeaders","getCenterFlatHeaders","getRightFlatHeaders","getCenterLeafHeaders","flatHeaders","_header$subHeaders","getLeftLeafHeaders","_header$subHeaders2","getRightLeafHeaders","_header$subHeaders3","_left$","_center$","_right$","getHeaderGroupProps","getFooterGroupProps","initialProps","getTotalWidth","columnsToGroup","headerFamily","findMaxDepth","_column$columns","createHeaderGroup","headersToGroup","getterValue","parentHeaders","headerToGroup","latestParentHeader","recurseHeadersForSpans","childRowSpans","childColSpan","childRowSpan","_headerGroups$","features","_createTable","__","__options","generics","createColumns","createDisplayColumn","columnDefType","createGroup","createDataColumn","accessor","accessorKey","filterRowModelFromLeafs","rowsToFilter","filterRows","newFilteredFlatRows","newFilteredRowsById","recurseFilterRows","original","filterRowModelFromRoot","sortedRowModel","expandedRows","handleRow","preFilteredRows","defaultOptions","feature","buildOptions","finalInstance","reset","setOptions","getRowId","state","onStateChange","defaultColumn","getColumnDefs","columnDef","originalRow","getFlatColumns","flatMap","_column$columns2","columnDefs","recurseColumns","getAllFlatColumnsById","flatColumns","acc","getCellProps","renderCell","rowIndex","getLeafRows","getRowProps","data","accessRow","parentRows","getSubRows","originalSubRows","getCell","getTableProps","getTableBodyProps","getTableWidth","_instance$getHeaderGr2","getLeftTableWidth","_instance$getLeftHead2","getCenterTableWidth","_instance$getCenterHe2","getRightTableWidth","_instance$getRightHea2","filterableColumnIds","existingGrouping","groupedFlatRows","groupedRowsById","groupedRows","groupUpRecursively","parentId","rowGroupsMap","groupMap","resKey","previous","groupBy","aggregatedGroupedRows","entries","groupingValue","leafRows","aggregateFn","columnValue","aggregateValue","aggregateRowsToValues","createTableFactory","factoryOptions","createTable","pageStart","pageEnd","sortingState","sortedFlatRows","availableSorting","columnInfoById","sortEntry","sortUndefined","invertSorting","sortData","sortedData","columnInfo","isDesc","aUndefined","bUndefined","sortInt"],"mappings":"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"}
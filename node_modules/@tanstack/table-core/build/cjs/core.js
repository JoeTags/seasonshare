/**
 * table-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var utils = require('./utils.js');
var ColumnSizing = require('./features/ColumnSizing.js');
var Expanding = require('./features/Expanding.js');
var Filters = require('./features/Filters.js');
var Grouping = require('./features/Grouping.js');
var Ordering = require('./features/Ordering.js');
var Pagination = require('./features/Pagination.js');
var Pinning = require('./features/Pinning.js');
var RowSelection = require('./features/RowSelection.js');
var Sorting = require('./features/Sorting.js');
var Visibility = require('./features/Visibility.js');
var Headers = require('./features/Headers.js');

var features = [Headers.Headers, Visibility.Visibility, Ordering.Ordering, Pinning.Pinning, Filters.Filters, Sorting.Sorting, Grouping.Grouping, Expanding.Expanding, Pagination.Pagination, RowSelection.RowSelection, ColumnSizing.ColumnSizing];
function createTableInstance(options) {
  var _options$initialState;

  if (options.debugAll || options.debugTable) {
    console.info('Creating Table Instance...');
  }

  var instance = {};
  var defaultOptions = features.reduce(function (obj, feature) {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(instance));
  }, {});

  var buildOptions = function buildOptions(options) {
    return _rollupPluginBabelHelpers["extends"]({}, defaultOptions, options);
  };

  instance.options = buildOptions(options);

  var initialState = _rollupPluginBabelHelpers["extends"]({}, features.reduce(function (obj, feature) {
    return Object.assign(obj, feature.getInitialState == null ? void 0 : feature.getInitialState());
  }, {}), (_options$initialState = options.initialState) != null ? _options$initialState : {});

  var finalInstance = _rollupPluginBabelHelpers["extends"]({}, instance, features.reduce(function (obj, feature) {
    return Object.assign(obj, feature.getInstance == null ? void 0 : feature.getInstance(instance));
  }, {}), {
    initialState: initialState,
    reset: function reset() {
      instance.setState(instance.initialState);
    },
    setOptions: function setOptions(updater) {
      instance.options = buildOptions(utils.functionalUpdate(updater, instance.options));
    },
    render: function render(template, props) {
      if (typeof instance.options.render === 'function') {
        return instance.options.render(template, props);
      }

      if (typeof template === 'function') {
        return template(props);
      }

      return template;
    },
    getRowId: function getRowId(_, index, parent) {
      return "" + (parent ? [parent.id, index].join('.') : index);
    },
    getState: function getState() {
      return instance.options.state;
    },
    setState: function setState(updater) {
      instance.options.onStateChange == null ? void 0 : instance.options.onStateChange(updater);
    },
    getDefaultColumn: utils.memo(function () {
      return [instance.options.defaultColumn];
    }, function (defaultColumn) {
      var _defaultColumn;

      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return _rollupPluginBabelHelpers["extends"]({
        header: function header(props) {
          return props.header.column.id;
        },
        footer: function footer(props) {
          return props.header.column.id;
        },
        cell: function cell(_ref) {
          var _ref$value = _ref.value,
              value = _ref$value === void 0 ? '' : _ref$value;
          return typeof value === 'boolean' ? value.toString() : value;
        }
      }, features.reduce(function (obj, feature) {
        return Object.assign(obj, feature.getDefaultColumn == null ? void 0 : feature.getDefaultColumn());
      }, {}), defaultColumn);
    }, {
      debug: function debug() {
        var _instance$options$deb;

        return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugColumns;
      },
      key: 'getDefaultColumn'
    }),
    getColumnDefs: function getColumnDefs() {
      return instance.options.columns;
    },
    createColumn: function createColumn(columnDef, depth, parent) {
      var _ref2, _columnDef$id;

      var defaultColumn = instance.getDefaultColumn();
      var id = (_ref2 = (_columnDef$id = columnDef.id) != null ? _columnDef$id : columnDef.accessorKey) != null ? _ref2 : typeof columnDef.header === 'string' ? columnDef.header : undefined;
      var accessorFn;

      if (columnDef.accessorFn) {
        accessorFn = columnDef.accessorFn;
      } else if (columnDef.accessorKey) {
        accessorFn = function accessorFn(originalRow) {
          return originalRow[columnDef.accessorKey];
        };
      }

      if (!id) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error(columnDef.accessorFn ? "Columns require an id when using an accessorFn" : "Columns require an id when using a non-string header");
        }

        throw new Error();
      }

      var column = _rollupPluginBabelHelpers["extends"]({}, defaultColumn, columnDef, {
        id: "" + id,
        accessorFn: accessorFn,
        parent: parent,
        depth: depth,
        columnDef: columnDef,
        columnDefType: columnDef.columnDefType,
        columns: [],
        getWidth: function getWidth() {
          return instance.getColumnWidth(column.id);
        },
        getFlatColumns: utils.memo(function () {
          return [true];
        }, function () {
          var _column$columns;

          return [column].concat((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(function (d) {
            return d.getFlatColumns();
          }));
        }, {
          key: 'column.getFlatColumns',
          debug: function debug() {
            var _instance$options$deb2;

            return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugColumns;
          }
        }),
        getLeafColumns: utils.memo(function () {
          return [instance.getOrderColumnsFn()];
        }, function (orderColumns) {
          var _column$columns2;

          if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
            var leafColumns = column.columns.flatMap(function (column) {
              return column.getLeafColumns();
            });
            return orderColumns(leafColumns);
          }

          return [column];
        }, {
          key: 'column.getLeafColumns',
          debug: function debug() {
            var _instance$options$deb3;

            return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugColumns;
          }
        })
      });

      column = features.reduce(function (obj, feature) {
        return Object.assign(obj, feature.createColumn == null ? void 0 : feature.createColumn(column, instance));
      }, column); // Yes, we have to convert instance to uknown, because we know more than the compiler here.

      return column;
    },
    getAllColumns: utils.memo(function () {
      return [instance.getColumnDefs()];
    }, function (columnDefs) {
      var recurseColumns = function recurseColumns(columnDefs, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }

        return columnDefs.map(function (columnDef) {
          var column = instance.createColumn(columnDef, depth, parent);
          column.columns = columnDef.columns ? recurseColumns(columnDef.columns, column, depth + 1) : [];
          return column;
        });
      };

      return recurseColumns(columnDefs);
    }, {
      key: 'getAllColumns',
      debug: function debug() {
        var _instance$options$deb4;

        return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugColumns;
      }
    }),
    getAllFlatColumns: utils.memo(function () {
      return [instance.getAllColumns()];
    }, function (allColumns) {
      return allColumns.flatMap(function (column) {
        return column.getFlatColumns();
      });
    }, {
      key: 'getAllFlatColumns',
      debug: function debug() {
        var _instance$options$deb5;

        return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugColumns;
      }
    }),
    getAllFlatColumnsById: utils.memo(function () {
      return [instance.getAllFlatColumns()];
    }, function (flatColumns) {
      return flatColumns.reduce(function (acc, column) {
        acc[column.id] = column;
        return acc;
      }, {});
    }, {
      key: 'getAllFlatColumnsById',
      debug: function debug() {
        var _instance$options$deb6;

        return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugColumns;
      }
    }),
    getAllLeafColumns: utils.memo(function () {
      return [instance.getAllColumns(), instance.getOrderColumnsFn()];
    }, function (allColumns, orderColumns) {
      var leafColumns = allColumns.flatMap(function (column) {
        return column.getLeafColumns();
      });
      return orderColumns(leafColumns);
    }, {
      key: 'getAllLeafColumns',
      debug: function debug() {
        var _instance$options$deb7;

        return (_instance$options$deb7 = instance.options.debugAll) != null ? _instance$options$deb7 : instance.options.debugColumns;
      }
    }),
    getColumn: function getColumn(columnId) {
      var column = instance.getAllFlatColumnsById()[columnId];

      if (!column) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn("[Table] Column with id " + columnId + " does not exist.");
        }

        throw new Error();
      }

      return column;
    },
    createCell: function createCell(row, column, value) {
      var cell = {
        id: row.id + "_" + column.id,
        rowId: row.id,
        columnId: column.id,
        row: row,
        column: column,
        value: value,
        getCellProps: function getCellProps(userProps) {
          return instance.getCellProps(row.id, column.id, userProps);
        },
        renderCell: function renderCell() {
          return column.cell ? instance.render(column.cell, {
            instance: instance,
            column: column,
            row: row,
            cell: cell,
            value: value
          }) : null;
        }
      };
      features.forEach(function (feature) {
        Object.assign(cell, feature.createCell == null ? void 0 : feature.createCell(cell, column, row, instance));
      }, {});
      return cell;
    },
    createRow: function createRow(id, original, rowIndex, depth, values) {
      var row = {
        id: id,
        index: rowIndex,
        original: original,
        depth: depth,
        values: values,
        subRows: [],
        getLeafRows: function getLeafRows() {
          return utils.flattenBy(row.subRows, function (d) {
            return d.subRows;
          });
        },
        getRowProps: function getRowProps(userProps) {
          return instance.getRowProps(row.id, userProps);
        },
        getAllCells: undefined,
        getAllCellsByColumnId: undefined
      };
      row.getAllCells = utils.memo(function () {
        return [instance.getAllLeafColumns()];
      }, function (leafColumns) {
        return leafColumns.map(function (column) {
          return instance.createCell(row, column, row.values[column.id]);
        });
      }, {
        key: process.env.NODE_ENV !== 'production' ? 'row.getAllCells' : '',
        debug: function debug() {
          var _instance$options$deb8;

          return (_instance$options$deb8 = instance.options.debugAll) != null ? _instance$options$deb8 : instance.options.debugRows;
        }
      });
      row.getAllCellsByColumnId = utils.memo(function () {
        return [row.getAllCells()];
      }, function (allCells) {
        return allCells.reduce(function (acc, cell) {
          acc[cell.columnId] = cell;
          return acc;
        }, {});
      }, {
        key: 'row.getAllCellsByColumnId',
        debug: function debug() {
          var _instance$options$deb9;

          return (_instance$options$deb9 = instance.options.debugAll) != null ? _instance$options$deb9 : instance.options.debugRows;
        }
      });

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        Object.assign(row, feature.createRow == null ? void 0 : feature.createRow(row, instance));
      }

      return row;
    },
    getCoreRowModel: utils.memo(function () {
      return [instance.options.data];
    }, function (data) {
      // Access the row model using initial columns
      var rows = [];
      var flatRows = [];
      var rowsById = {};
      var leafColumns = instance.getAllLeafColumns();

      var accessRow = function accessRow(originalRow, rowIndex, depth, parentRows, parent) {
        if (depth === void 0) {
          depth = 0;
        }

        var id = instance.getRowId(originalRow, rowIndex, parent);

        if (!id) {
          if (process.env.NODE_ENV !== 'production') {
            throw new Error("getRowId expected an ID, but got " + id);
          }
        }

        var values = {};

        for (var i = 0; i < leafColumns.length; i++) {
          var _column = leafColumns[i];

          if (_column && _column.accessorFn) {
            values[_column.id] = _column.accessorFn(originalRow, rowIndex);
          }
        } // Make the row


        var row = instance.createRow(id, originalRow, rowIndex, depth, values); // Push instance row into the parentRows array

        parentRows.push(row); // Keep track of every row in a flat array

        flatRows.push(row); // Also keep track of every row by its ID

        rowsById[id] = row; // Get the original subrows

        if (instance.options.getSubRows) {
          var originalSubRows = instance.options.getSubRows(originalRow, rowIndex); // Then recursively access them

          if (originalSubRows != null && originalSubRows.length) {
            row.originalSubRows = originalSubRows;
            var subRows = [];

            for (var _i = 0; _i < row.originalSubRows.length; _i++) {
              accessRow(row.originalSubRows[_i], _i, depth + 1, subRows, row);
            }

            row.subRows = subRows;
          }
        }
      };

      for (var i = 0; i < data.length; i++) {
        accessRow(data[i], i, 0, rows);
      }

      return {
        rows: rows,
        flatRows: flatRows,
        rowsById: rowsById
      };
    }, {
      key: 'getRowModel',
      debug: function debug() {
        var _instance$options$deb10;

        return (_instance$options$deb10 = instance.options.debugAll) != null ? _instance$options$deb10 : instance.options.debugTable;
      },
      onChange: function onChange() {
        instance._notifyFiltersReset();

        instance._notifyRowSelectionReset();
      }
    }),
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: function getRowModel() {
      return instance.getPaginationRowModel();
    },
    getRow: function getRow(id) {
      var row = instance.getRowModel().rowsById[id];

      if (!row) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error("getRow expected an ID, but got " + id);
        }

        throw new Error();
      }

      return row;
    },
    getCell: function getCell(rowId, columnId) {
      var row = instance.getRow(rowId);

      if (!row) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error("[Table] could not find row with id " + rowId);
        }

        throw new Error();
      }

      var cell = row.getAllCellsByColumnId()[columnId];

      if (!cell) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error("[Table] could not find cell " + columnId + " in row " + rowId);
        }

        throw new Error();
      }

      return cell;
    },
    getTableProps: function getTableProps(userProps) {
      return utils.propGetter({
        role: 'table'
      }, userProps);
    },
    getTableBodyProps: function getTableBodyProps(userProps) {
      return utils.propGetter({
        role: 'rowgroup'
      }, userProps);
    },
    getRowProps: function getRowProps(rowId, userProps) {
      var row = instance.getRow(rowId);

      if (!row) {
        return;
      }

      return utils.propGetter({
        key: row.id,
        role: 'row'
      }, userProps);
    },
    getCellProps: function getCellProps(rowId, columnId, userProps) {
      var cell = instance.getCell(rowId, columnId);

      if (!cell) {
        return;
      }

      return utils.propGetter({
        key: cell.id,
        role: 'gridcell'
      }, userProps);
    },
    getTableWidth: function getTableWidth() {
      var _instance$getHeaderGr, _instance$getHeaderGr2;

      return (_instance$getHeaderGr = (_instance$getHeaderGr2 = instance.getHeaderGroups()[0]) == null ? void 0 : _instance$getHeaderGr2.headers.reduce(function (sum, header) {
        return sum + header.getWidth();
      }, 0)) != null ? _instance$getHeaderGr : 0;
    },
    getLeftTableWidth: function getLeftTableWidth() {
      var _instance$getLeftHead, _instance$getLeftHead2;

      return (_instance$getLeftHead = (_instance$getLeftHead2 = instance.getLeftHeaderGroups()[0]) == null ? void 0 : _instance$getLeftHead2.headers.reduce(function (sum, header) {
        return sum + header.getWidth();
      }, 0)) != null ? _instance$getLeftHead : 0;
    },
    getCenterTableWidth: function getCenterTableWidth() {
      var _instance$getCenterHe, _instance$getCenterHe2;

      return (_instance$getCenterHe = (_instance$getCenterHe2 = instance.getCenterHeaderGroups()[0]) == null ? void 0 : _instance$getCenterHe2.headers.reduce(function (sum, header) {
        return sum + header.getWidth();
      }, 0)) != null ? _instance$getCenterHe : 0;
    },
    getRightTableWidth: function getRightTableWidth() {
      var _instance$getRightHea, _instance$getRightHea2;

      return (_instance$getRightHea = (_instance$getRightHea2 = instance.getRightHeaderGroups()[0]) == null ? void 0 : _instance$getRightHea2.headers.reduce(function (sum, header) {
        return sum + header.getWidth();
      }, 0)) != null ? _instance$getRightHea : 0;
    }
  });

  instance = Object.assign(instance, finalInstance);
  return instance;
}

exports.createTableInstance = createTableInstance;
//# sourceMappingURL=core.js.map

{"version":3,"file":"groupRowsFn.js","sources":["../../../src/utils/groupRowsFn.ts"],"sourcesContent":["import {\n  TableInstance,\n  Row,\n  RowModel,\n  AnyGenerics,\n  PartialGenerics,\n} from '../types'\nimport { flattenBy } from '../utils'\n\nexport function groupRowsFn<TGenerics extends AnyGenerics>(\n  instance: TableInstance<TGenerics>,\n  sortedRowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const groupingState = instance.getState().grouping\n  // Filter the grouping list down to columns that exist\n  const existingGrouping = groupingState.filter(columnId =>\n    instance.getColumn(columnId)\n  )\n\n  // Find the columns that can or are aggregating\n  // Uses each column to aggregate rows into a single value\n  const aggregateRowsToValues = (\n    leafRows: Row<TGenerics>[],\n    groupedRows: Row<TGenerics>[],\n    depth: number\n  ) => {\n    const values: Record<string, unknown> = {}\n\n    instance.getAllLeafColumns().forEach(column => {\n      // Don't aggregate columns that are in the grouping\n      if (existingGrouping.includes(column.id)) {\n        values[column.id] = groupedRows[0]\n          ? groupedRows[0].values[column.id]\n          : null\n        return\n      }\n\n      // Aggregate the values\n      const aggregateFn = instance.getColumnAggregationFn(column.id)\n\n      if (aggregateFn) {\n        values[column.id] = aggregateFn(\n          () =>\n            leafRows.map(row => {\n              let columnValue = row.values[column.id]\n\n              if (!depth && column.aggregateValue) {\n                columnValue = column.aggregateValue(columnValue)\n              }\n\n              return columnValue\n            }),\n          () => groupedRows.map(row => row.values[column.id])\n        )\n      } else if (column.aggregationType) {\n        console.info({ column })\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `Table: Invalid column.aggregateType option for column listed above`\n            : ''\n        )\n      } else {\n        values[column.id] = null\n      }\n    })\n\n    return values\n  }\n\n  const groupedFlatRows: Row<TGenerics>[] = []\n  const groupedRowsById: Record<string, Row<TGenerics>> = {}\n  // const onlyGroupedFlatRows: Row[] = [];\n  // const onlyGroupedRowsById: Record<RowId, Row> = {};\n  // const nonGroupedFlatRows: Row[] = [];\n  // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n  // Recursively group the data\n  const groupUpRecursively = (\n    rows: Row<TGenerics>[],\n    depth = 0,\n    parentId: string\n  ) => {\n    // This is the last level, just return the rows\n    if (depth === existingGrouping.length) {\n      return rows\n    }\n\n    const columnId = existingGrouping[depth]!\n\n    // Group the rows together for this level\n    const rowGroupsMap = groupBy(rows, columnId)\n\n    // Peform aggregations for each group\n    const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map(\n      ([groupingValue, groupedRows], index) => {\n        let id = `${columnId}:${groupingValue}`\n        id = parentId ? `${parentId}>${id}` : id\n\n        // First, Recurse to group sub rows before aggregation\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n        // Flatten the leaf rows of the rows in this group\n        const leafRows = depth\n          ? flattenBy(groupedRows, row => row.subRows)\n          : groupedRows\n\n        const values = aggregateRowsToValues(leafRows, groupedRows, depth)\n\n        const row = instance.createRow(id, undefined, index, depth, values)\n\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n        })\n\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow)\n          groupedRowsById[subRow.id] = subRow\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        })\n\n        return row\n      }\n    )\n\n    return aggregatedGroupedRows\n  }\n\n  const groupedRows = groupUpRecursively(sortedRowModel.rows, 0, '')\n\n  groupedRows.forEach(subRow => {\n    groupedFlatRows.push(subRow)\n    groupedRowsById[subRow.id] = subRow\n    // if (subRow.getIsGrouped?.()) {\n    //   onlyGroupedFlatRows.push(subRow);\n    //   onlyGroupedRowsById[subRow.id] = subRow;\n    // } else {\n    //   nonGroupedFlatRows.push(subRow);\n    //   nonGroupedRowsById[subRow.id] = subRow;\n    // }\n  })\n\n  return {\n    rows: groupedRows,\n    flatRows: groupedFlatRows,\n    rowsById: groupedRowsById,\n  }\n}\n\nfunction groupBy<TGenerics extends AnyGenerics>(\n  rows: Row<TGenerics>[],\n  columnId: string\n) {\n  const groupMap = new Map<any, Row<TGenerics>[]>()\n\n  return rows.reduce((map, row) => {\n    const resKey = `${row.values[columnId]}`\n    const previous = map.get(resKey)\n    if (!previous) {\n      map.set(resKey, [row])\n    } else {\n      map.set(resKey, [...previous, row])\n    }\n    return map\n  }, groupMap)\n}\n"],"names":["groupRowsFn","instance","sortedRowModel","groupingState","getState","grouping","existingGrouping","filter","columnId","getColumn","aggregateRowsToValues","leafRows","groupedRows","depth","values","getAllLeafColumns","forEach","column","includes","id","aggregateFn","getColumnAggregationFn","map","row","columnValue","aggregateValue","aggregationType","console","info","Error","process","env","NODE_ENV","groupedFlatRows","groupedRowsById","groupUpRecursively","rows","parentId","length","rowGroupsMap","groupBy","aggregatedGroupedRows","Array","from","entries","index","groupingValue","subRows","flattenBy","createRow","undefined","Object","assign","groupingColumnId","subRow","push","flatRows","rowsById","groupMap","Map","reduce","resKey","previous","get","set"],"mappings":"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"}